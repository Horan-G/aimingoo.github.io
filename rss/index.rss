<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Aimingoo's Blog]]></title><description><![CDATA[何不乐乐而有哉]]></description><link>http://aimingoo.github.io/</link><image><url>http://aimingoo.github.io/favicon.png</url><title>Aimingoo&apos;s Blog</title><link>http://aimingoo.github.io/</link></image><generator>Ghost 1.14</generator><lastBuildDate>Sun, 26 Aug 2018 06:14:53 GMT</lastBuildDate><atom:link href="http://aimingoo.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[JavaScript中创建原子的几种方法]]></title><description><![CDATA[<div class="kg-card-markdown"><blockquote>
<p>本文是“JavaScript的元语言”系列中的一篇。其它内容参见：</p>
<ul>
<li>JavaScript的元系统: <a href="https://aimingoo.github.io/5b7f6efac66182831afb497b.html">https://aimingoo.github.io/5b7f6efac66182831afb497b.html</a></li>
</ul>
</blockquote>
<p>JavaScript中可以通过<code>Object.create(null)</code>来创建原子，这是非常自然而又易于理解的方式。不过也有一些其它的方法来实现相同的效果，虽然在概念上有所不同，但是它们创建的一样是“原子对象”。</p>
<h2 id="">创建原子</h2>
<ul>
<li>使用Object.create()</li>
</ul>
<pre><code class="language-javascript">// 方法1
atom = Object.create(null)
</code></pre>
<ul>
<li>使用Object.setPrototypeOf()</li>
</ul>
<pre><code class="language-javascript">// 方法2
atom = Object.setPrototypeOf(new Object, null)

// OR
atom = Object.setPrototypeOf({}, null)
</code></pre>
<ul>
<li>重置构造器的原型属性</li>
</ul>
<pre><code class="language-javascript">// 方法3
function MyObject() {
    // ...
}
Object.setPrototypeOf(MyObject.</code></pre></div>]]></description><link>http://aimingoo.github.io/5b824316c66182831afb4982/</link><guid isPermaLink="false">5b824316c66182831afb4982</guid><category><![CDATA[Javascript]]></category><category><![CDATA[语言]]></category><category><![CDATA[元语言]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 26 Aug 2018 06:06:59 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><blockquote>
<p>本文是“JavaScript的元语言”系列中的一篇。其它内容参见：</p>
<ul>
<li>JavaScript的元系统: <a href="https://aimingoo.github.io/5b7f6efac66182831afb497b.html">https://aimingoo.github.io/5b7f6efac66182831afb497b.html</a></li>
</ul>
</blockquote>
<p>JavaScript中可以通过<code>Object.create(null)</code>来创建原子，这是非常自然而又易于理解的方式。不过也有一些其它的方法来实现相同的效果，虽然在概念上有所不同，但是它们创建的一样是“原子对象”。</p>
<h2 id="">创建原子</h2>
<ul>
<li>使用Object.create()</li>
</ul>
<pre><code class="language-javascript">// 方法1
atom = Object.create(null)
</code></pre>
<ul>
<li>使用Object.setPrototypeOf()</li>
</ul>
<pre><code class="language-javascript">// 方法2
atom = Object.setPrototypeOf(new Object, null)

// OR
atom = Object.setPrototypeOf({}, null)
</code></pre>
<ul>
<li>重置构造器的原型属性</li>
</ul>
<pre><code class="language-javascript">// 方法3
function MyObject() {
    // ...
}
Object.setPrototypeOf(MyObject.prototype, null);

atom = new MyObject;
</code></pre>
<ul>
<li>重置类的原型</li>
</ul>
<p>注：“非派生类（没有extends声明的类）”，与将一个普通函数用作构造器时的特性基本一致。</p>
<pre><code class="language-javascript">class MyClass {
    // ...
}
Object.setPrototypeOf(MyClass.prototype, null);

atom = new MyClass;
</code></pre>
<ul>
<li>使用派生自null值的类</li>
</ul>
<p>JavaScript在处理<code>extends null</code>时会将<code>MyClass.prototype</code>的原型置为<code>null</code>，因此这个类构建的实例自然就是atom。但是，派生自null值的类无法直接构建，因此需要声明自己的构造方法（以该方法创建和返回的对象作为this）。</p>
<pre><code class="language-javascript">// 方法4
class MyClass extends null {
    constructor() {
        return Object.create(new.target.prototype);
    }
}
atom = new MyClass;
</code></pre>
<p>上例在实现构造方法<code>constructor()</code>时是直接引用<code>new.target.prototype</code>来作为原型的，这样也就可以在<code>new</code>运算时引用到<code>MyClass</code>子类的原型。例如：</p>
<pre><code class="language-javascript">// 方法5
class MyClassEx extends MyClass {
    get description() {
        return 'class MyClassEx';
    }
}
atom = new MyClassEx;
console.log(atom.description); // class MyClassEx
</code></pre>
<ul>
<li>使用一般函数并直接返回原子</li>
</ul>
<p>下面的代码是兼容构造器、原型继承和函数调用等方式的。</p>
<pre><code class="language-javascript">// 方法6
// （当作为函数调用时,new.target为undefined值）
function MyAtom() {
    return Object.create(new.target &amp;&amp; new.target.prototype || null);
}

// 示例1
atom = new MyAtom;
// 示例2
atom = MyAtom();
</code></pre>
<h2 id="">使用类来创建原子的一个特例</h2>
<p>在上述方法4中，由于声明了<code>extends null</code>，因此类<code>MyClass</code>必须拥有一个自己的构造方法。但事实上在JavaScript中，<code>extends null</code>所表达的含义是：</p>
<ul>
<li>因为有<code>extends</code>声明，所以默认的<code>constructor()</code>将总是调用父类<code>super()</code>来创建实例（亦即是所谓“<code>this</code>引用总是由祖先类创建的”）；但是，</li>
<li>由于<code>extends null</code>意味着父类为null，因此“调用父类<code>super()</code>”失败。</li>
</ul>
<p>这是类<code>MyClass</code>不能使用默认的<code>constructor()</code>——而“通常”必须由用户代码来实现构造方法的原因。然而JavaScript只是在静态语法分析时才通过<code>extends null</code>来识别父类，真正在运行期时，它是通过方法的内部槽(<code>[[HomeObject]]</code>)来动态查找super的。——由于该内部槽指向类<code>MyClass</code>（或类的原型属性<code>MyClass.prototype</code>），因此所谓的<code>super</code>其实就是如下的运算值：</p>
<pre><code class="language-javascript">// for static class methods
_super = Object.getPrototypeOf(MyClass)

// for instance methods
_super = Object.getPrototypeOf(MyClass.prototype)
</code></pre>
<p>既然如此，我们就可以通过如下的代码来声明一个“可以创建原子”的类。例如：</p>
<pre><code class="language-javascript">// 方法7
Atom = Object.setPrototypeOf(class extends null {}, Object)
atom = new Atom;
</code></pre>
<p>在这个方法中，实际上Atom指向类表达式，并且重置了它的原型：</p>
<pre><code class="language-javascript">// （如下等价于方法7的第一行代码）
Atom = class extends null {};
Object.setPrototypeOf(Atom.prototype, null);
Object.setPrototypeOf(Atom, Object);
</code></pre>
<p>其中<code>extends null</code>决定了<code>Atom.prototype</code>的原型指向一个null值，而<code>setPrototypeOf(...)</code>决定了当<code>new Atom()</code>时，对象实际上是由<code>Object()</code>——这个super来创建的。因此，当<code>new Atom</code>时，实际发生的操作是：</p>
<pre><code class="language-javascript">// （如下等价于方法7的第二行代码）
_this = new Object(); // call super()
Object.setPrototypeOf(_this, Atom.prototype); // prototype is null
atom = _this;
</code></pre>
<p>所以方法7是一种能够“利用JavaScript原生构造器”来创建原子的技巧。比如最简单的获得一个<code>Arguments()</code>构造器的方法其实是这样：</p>
<pre><code class="language-javascript">let Arguments = Object.setPrototypeOf(class extends null {}, Array);
</code></pre>
<p>这样得到的对象将与JavaScript内置在函数调用中创建的<code>argument</code>完全一致：</p>
<pre><code class="language-javascript">// （JavaScript的arguments对象也是原子）
let arguments = new Arguments(1,2,3); // more paraments
</code></pre>
<p>不过在ES6中<code>arguments</code>也实现了迭代器界面，因此需要一行额外的代码来处理之：</p>
<pre><code class="language-javascript">// for ES6
Arguments.prototype[Symbol.iterator] = [][Symbol.iterator];
</code></pre>
<h2 id="">其它</h2>
<h4 id="1">1. 关于映射类</h4>
<p>在Metameta(<a href="https://github.com/aimingoo/metameta">@aimingoo/metameta</a>)中，可以使用<code>Meta.from()</code>来得到一个映射类，这与上面的方法7是相同的方式：</p>
<pre><code class="language-javascript">// 方法8（in metameta）
MyAtomObject = Meta.from(Object);
atom = new MyAtomObject;
</code></pre>
<p>有趣的是，这样得到的“<code>MyAtomObject</code>类”（在Metameta中称为<code>Objext</code>类）将继承所有来自<code>Object.xxx</code>的类方法，例如<code>Object.keys()</code>等。这些方法在元系统中也是可以直接使用的。例如：</p>
<pre><code class="language-javascript">// (in metameta)
Objext = Meta.from(Object);
Objext.keys(new Objext);
</code></pre>
<h4 id="2extendsnewtarget">2. 关于<code>extends new.target</code></h4>
<p>上面在方法4中提到<code>extends null</code>相当于将<code>MyClass.prototype</code>的原型设为null，——在方法7中也使用了这一技巧——因此事实上在Metameta(<a href="https://github.com/aimingoo/metameta">@aimingoo/metameta</a>)中实现MetaMeta()时，采用的<code>extends new.target</code>也就相当于：</p>
<pre><code class="language-javascript">// class MyClass extends new.target ...
Object.setPrototypeOf(MyClass.prototype, new.target)
</code></pre>
<p>这一技巧用在类的<code>constructor()</code>方法中，返回一个新的类（类声明的表达式）。</p>
</div>]]></content:encoded></item><item><title><![CDATA[JavaScript的元系统]]></title><description><![CDATA[<div class="kg-card-markdown"><h1 id="javascript">JavaScript的元系统</h1>
<blockquote>
<p>本文是对在第四届FEDay中分享的《无类继承：JavaScript面向对象的根基》的进一步讨论。也是对开源项目<a href="https://github.com/aimingoo/metameta">@aimingoo/metameta</a>的解析。</p>
</blockquote>
<p>ECMAScript中只有两处提及到“Meta”这个概念，一处是说明ECMAScript的规范类型（<em>a specification type</em>）是用于描述和实现语言类型（<em>language types</em>）的元值（<em>meta-values</em>），另一处则是唯一被称为“元属性（<em>Meta Property</em>）”的<code>new.target</code>。</p>
<p>所以ECMAScript中是没有所谓“元系统（<em>Meta system</em>）”或“元类型系统（<em>Meta type system</em>）”。我们在这里先定义一个称为“原子（<em>Atom</em>）”的东西，并基于此来构建起一个完整的JavaScript元系统。</p>
<h2 id="atom">原子（atom）</h2>
<blockquote>
<p>定义：原子是JavaScript中的对象的最小单元，它是对象但不继承自Object()；以原子为原型的对象也会被称为原子对象。</p>
</blockquote>
<p>JavaScript中的对象就是一个属性包（<em>properties</em></p></div>]]></description><link>http://aimingoo.github.io/5b7f6efac66182831afb497b/</link><guid isPermaLink="false">5b7f6efac66182831afb497b</guid><category><![CDATA[Javascript]]></category><category><![CDATA[语言]]></category><category><![CDATA[元语言]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Fri, 24 Aug 2018 02:57:14 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><h1 id="javascript">JavaScript的元系统</h1>
<blockquote>
<p>本文是对在第四届FEDay中分享的《无类继承：JavaScript面向对象的根基》的进一步讨论。也是对开源项目<a href="https://github.com/aimingoo/metameta">@aimingoo/metameta</a>的解析。</p>
</blockquote>
<p>ECMAScript中只有两处提及到“Meta”这个概念，一处是说明ECMAScript的规范类型（<em>a specification type</em>）是用于描述和实现语言类型（<em>language types</em>）的元值（<em>meta-values</em>），另一处则是唯一被称为“元属性（<em>Meta Property</em>）”的<code>new.target</code>。</p>
<p>所以ECMAScript中是没有所谓“元系统（<em>Meta system</em>）”或“元类型系统（<em>Meta type system</em>）”。我们在这里先定义一个称为“原子（<em>Atom</em>）”的东西，并基于此来构建起一个完整的JavaScript元系统。</p>
<h2 id="atom">原子（atom）</h2>
<blockquote>
<p>定义：原子是JavaScript中的对象的最小单元，它是对象但不继承自Object()；以原子为原型的对象也会被称为原子对象。</p>
</blockquote>
<p>JavaScript中的对象就是一个属性包（<em>properties bag, or a collection of properties</em>），一个属性包为空集时，它必然是对象的最小形态。因此一个没有原型，且自有属性集为空的对象，必然是一个原子。</p>
<p>原子可以用ES5兼容的语法创建出来：</p>
<pre><code class="language-javascript">var atom = Object.create(null);
</code></pre>
<p>也可以通过将一般对象的原型置为null来得到一个原子：</p>
<pre><code class="language-javascript">var atom = Object.setPrototypeOf(new Object, null);
</code></pre>
<p>并且，在ECMAScript中有四个内建/原生对象是原子的：</p>
<pre><code class="language-javascript">function isAtom(x) {
    switch (typeof x) {
        case 'object':
        case 'function': return !(x instanceof Object);
    }
    return false;
}

// modules in es6
import * as namespace from './your-module.js';

// arguments from function
var args = Function('return arguments')();

console.log(isAtom(null));
console.log(isAtom(Object.prototype));
console.log(isAtom(namespace));
console.log(isAtom(args));
</code></pre>
<p>在同一个运行环境中，可以并存多个原子，以及由原型指向原子的、原型继承的对象系统。所有这些原子以及衍生的对象系统都是互不相等、没有交集的。</p>
<pre><code class="language-javascript">&gt; Object.create(null) === Object.create(null)
false
</code></pre>
<p>因此，JavaScript原生的、由Object()派生或创建的对象、类，在本质上也是上述“对象系统”之一。但是，</p>
<ul>
<li>作为唯一特例，Object()所属的对象系统称为“原生对象系统”，以区别于后来创建的其它原子对象系统。</li>
</ul>
<p>并且，</p>
<ul>
<li>作为唯一特例，null值是一个原子（注：原子在ECMAScript约定的ECMAScript language types中不是对象，但在JavaScript自身的类型检查（<em>typeof</em>）中它是对象）。</li>
</ul>
<h2 id="meta">元（meta）</h2>
<blockquote>
<p>定义：能产生原子（atom）的一个过程称为元（meta）。</p>
<p>推论：原子的构造器(Atom)与元(meta)是等义的。</p>
</blockquote>
<p>由于atom对象的构造器通常记为Atom()，所以从概念上它与“元（meta）”是等义的，在实际使用中我们也并不明确地区分二者。</p>
<p>meta可以是一个函数，也可以是一个类，甚至也可以是一个代理对象（<em>proxy</em>）、箭头函数（<em>arrow functions</em>）或方法（<em>methods</em>）。——在概念定义中，我们只约定了“meta是一个过程”，并没有强调atom是它构建出来的，亦或只是它的调用结果。</p>
<p>在开源项目中Metameta（<a href="https://github.com/aimingoo/metameta">@aimingoo/metameta</a>）中，meta是以ES6的语法声明的一个Atom类：</p>
<pre><code class="language-javascript">class Atom extends null {
    constructor() {
        return Object.create(new.target.prototype);
    }
}
</code></pre>
<p>任何情况下，我们用该meta都可以产生新的原子对象：</p>
<pre><code class="language-javascript">&gt; isAtom(new Atom)
true

&gt; new Atom === new Atom
false
</code></pre>
<h2 id="metametatypes">元类型（Meta，Meta types）</h2>
<blockquote>
<p>定义：所有元（meta）的类型称为元类型（Meta types）</p>
</blockquote>
<p>在JavaScript中，一个数据所对应的类型可以用它的构造器来标示，亦即是Meta()；并且这也意味着Meta()作为构造器产生的实例是元（<em>meta</em>）。亦即是说，Meta()应当是一个“返回meta过程”的过程。</p>
<p>在ES6的语法中，可以简单地在函数中返回一个“类声明（<em>class definitions</em>）”来得到一个字面量风格的类。因此在Metameta中声明了MetaMeta()类来作为元类型的祖先类：</p>
<pre><code class="language-javascript">// Meta's super
class MetaMeta extends null {
  constructor(base) { // Atom() by default
    return Object.setPrototypeOf(class extends new.target {}, base);
  }
...
</code></pre>
<p>所以现在，我们就可以通过如下的方法来得到一个原子了：</p>
<pre><code class="language-javascript">// Atom与meta是同义的
&gt; Atom = meta = new MetaMeta

// 创建一个原子
&gt; atom = new Atom

// 检测
&gt; isAtom(atom)
true
</code></pre>
<h2 id="">基于原子的继承性</h2>
<p>我们之所以要用class来声明Atom和MetaMeta，是为了简单地得到面向对象的继承性。亦即是说，当我们想要派生一个新的原子对象类型的时候，可以简单地通过扩展上述的系统来得到它的构造器。例如：</p>
<pre><code class="language-javascript">class MyAtomObject extends new MetaMeta {
    get description() {
        return 'i am an atom.';
    }
}

var x = new MyAtomObject;
console.log(x.description);
</code></pre>
<p>在这个例子中，<code>new MetaMeta</code>直接创建了一个Atom，而<code>MyAtomObject</code>则派生自该Atom，因此它的实例自然是atom。并且，基于ES6的类声明语法，<code>MyAtomObject</code>也可以具有自己的存取器成员、对象方法，或者类方法。</p>
<h2 id="">基于元的继承性</h2>
<p>从MetaMeta也可以基于元类型进行派生，由此我们可以实现“元类（Meta class）类型”。</p>
<blockquote>
<p>定义：元类（Meta class）是一个产生类（class）的过程。</p>
</blockquote>
<p>从定义上来说，简单的元类可以写成：</p>
<pre><code class="language-javascript">function SimpleMetaClass() {
    return class {};
}
</code></pre>
<p>当然，由于在MetaMeta中“元类型”本身就是基于类实现的——亦即是它本来就是一个“返回类”的过程，因此它只需要简单的一层概念抽象就可以实现“元类”类型了。如下：</p>
<pre><code class="language-javascript">// “元(Meta)”类型
class Meta extends MetaMeta { ... }

// “元类(MetaClass)”类型
class MetaClass extends Meta { ... }
</code></pre>
<p>之所以让Meta派生自MetaMeta()，主要目的是为了得到一层super声明，以确保Meta()以及它的类方法（<em>static methods</em>）之于它的super是词法上下文绑定的。而“元类(MetaClass）”则用于派生一层类型声明，以便让MetaClass()能拥有自己的类方法，例如<code>MetaClass.isClassOf()</code>。</p>
<p>现在，我们已经在Meta上实现了一层派生，我们也可以实现更多层的派生，以通过“类类型”的方法来得到更多的构造器——换言之，我们可以产生更多的类，它们都可以作为更多的“不同的对象系统的”祖先类。我们可以让JavaScript中出现多个完全不同的、与Object()所代表的“原生对象系统”并列的对象系统。</p>
<p>如前所述的——它们相互独立，没有交集。例如：</p>
<pre><code class="language-javascript">// “元类(MetaClass)”产生类
var ObjectEx = new MetaClass;

// 基于ObjectEx可以派生一个“独立的、不同的”对象系统
class MyObjectEx extends ObjectEx {};

// 可以用类似的方法来派生更多这样的对象系统
class MyObjectPlus extends new MetaClass {
    ...
};
</code></pre>
<p>接下来，你可以检测它们的类属关系：</p>
<pre><code class="language-javascript">&gt; ObjectEx.isClassOf(MyObjectEx)
true

&gt; MetaClass.isClassOf(ObjectEx)
true
</code></pre>
<p>或使用ECMAScript内置方法检测原子：</p>
<pre><code class="language-javascript">&gt; (new MyObjectEx) instanceof ObjectEx
true

&gt; (new MyObjectEx) instanceof MyObjectPlus
false
</code></pre>
</div>]]></content:encoded></item><item><title><![CDATA[资源分享：第四届FEDay讲演主题]]></title><description><![CDATA[<div class="kg-card-markdown"><p>我在本届FEDay的讲演内容在这里了：</p>
<p>FEDay就是前端日，在这里：</p>
<ul>
<li><a href="https://fequan.com/2018/">https://fequan.com/2018/</a></li>
</ul>
<p>我的主题是《无类继承：JavaScript面向对象的根基》，主要是从JS中面向对象的历史讲起，一直到元类继承的实现。</p>
<p>相关的资源在这里：</p>
<ul>
<li>metameta: <a href="https://github.com/aimingoo/metameta">https://github.com/aimingoo/metameta</a></li>
<li>讲演内容下载：<a href="http://aimingoo.github.io/content/files/classless_inheritance_in_javascript.zip">/content/files/classless_inheritance_in_javascript.zip</a></li>
</ul>
</div>]]></description><link>http://aimingoo.github.io/5b7b77b6c66182831afb4977/</link><guid isPermaLink="false">5b7b77b6c66182831afb4977</guid><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Tue, 21 Aug 2018 02:32:22 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>我在本届FEDay的讲演内容在这里了：</p>
<p>FEDay就是前端日，在这里：</p>
<ul>
<li><a href="https://fequan.com/2018/">https://fequan.com/2018/</a></li>
</ul>
<p>我的主题是《无类继承：JavaScript面向对象的根基》，主要是从JS中面向对象的历史讲起，一直到元类继承的实现。</p>
<p>相关的资源在这里：</p>
<ul>
<li>metameta: <a href="https://github.com/aimingoo/metameta">https://github.com/aimingoo/metameta</a></li>
<li>讲演内容下载：<a href="http://aimingoo.github.io/content/files/classless_inheritance_in_javascript.zip">/content/files/classless_inheritance_in_javascript.zip</a></li>
</ul>
</div>]]></content:encoded></item><item><title><![CDATA[那些年，那些诗]]></title><description><![CDATA[<div class="kg-card-markdown"><p>在搞IT之前，我也搞点文学。</p>
<p>读书的时候总会写点东西，但不见得算文学作品。大概在99年的时候，我的《石像的忆述》被评成了网易首届网络文学大赛的金奖，看起来算是真正在做文学了，但此后我却也不怎么写东西了。后来有一阵爬坛论的风气，我跟着老茂的“顶点诗歌”混过一阵，也在精品论坛（ET8）和海浩网的文学版里出没，但几乎没有拿得出手的。再之后就是博客、微博和微信了，文学方面的作品更是寥寥。</p>
<p>但总归还是有些的。例如在其它博文中提到过的：</p>
<ul>
<li><a href="http://aimingoo.github.io/1-220">《澄心居诗词评读》六篇</a></li>
<li><a href="http://aimingoo.github.io/1-209">《独身茶寮》- 有人提问，我当作答。关于签名档的由来。</a></li>
<li><a href="http://aimingoo.github.io/59e2fcf072c9e7b37c38320c">《刀与磨刀》(之一)</a>、<a href="http://aimingoo.github.io/59e2fca072c9e7b37c383209">(之二)</a></li>
<li><a href="http://aimingoo.github.io/59e2e9b272c9e7b37c3831f0">《深夜食味记》1~5</a></li>
</ul>
<h2 id="">偶得</h2>
<p>除了这些之外，还有一些散碎文字。例如也曾经在博客中提到过的两首诗：</p>
<blockquote>
<p>之一·2008年入京</p>
<p>昨夜方泸闵，此时已京中。<br>
将相王侯府，笑谈作一梦。<br>
回见来时路，山峦几多重。<br>
俯仰清声处，执手是英雄。</p></blockquote></div>]]></description><link>http://aimingoo.github.io/59e6f1051bc77603d060b9ae/</link><guid isPermaLink="false">59e6f1051bc77603d060b9ae</guid><category><![CDATA[诗词文章]]></category><category><![CDATA[生活]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Wed, 18 Oct 2017 09:23:14 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>在搞IT之前，我也搞点文学。</p>
<p>读书的时候总会写点东西，但不见得算文学作品。大概在99年的时候，我的《石像的忆述》被评成了网易首届网络文学大赛的金奖，看起来算是真正在做文学了，但此后我却也不怎么写东西了。后来有一阵爬坛论的风气，我跟着老茂的“顶点诗歌”混过一阵，也在精品论坛（ET8）和海浩网的文学版里出没，但几乎没有拿得出手的。再之后就是博客、微博和微信了，文学方面的作品更是寥寥。</p>
<p>但总归还是有些的。例如在其它博文中提到过的：</p>
<ul>
<li><a href="http://aimingoo.github.io/1-220">《澄心居诗词评读》六篇</a></li>
<li><a href="http://aimingoo.github.io/1-209">《独身茶寮》- 有人提问，我当作答。关于签名档的由来。</a></li>
<li><a href="http://aimingoo.github.io/59e2fcf072c9e7b37c38320c">《刀与磨刀》(之一)</a>、<a href="http://aimingoo.github.io/59e2fca072c9e7b37c383209">(之二)</a></li>
<li><a href="http://aimingoo.github.io/59e2e9b272c9e7b37c3831f0">《深夜食味记》1~5</a></li>
</ul>
<h2 id="">偶得</h2>
<p>除了这些之外，还有一些散碎文字。例如也曾经在博客中提到过的两首诗：</p>
<blockquote>
<p>之一·2008年入京</p>
<p>昨夜方泸闵，此时已京中。<br>
将相王侯府，笑谈作一梦。<br>
回见来时路，山峦几多重。<br>
俯仰清声处，执手是英雄。</p>
<p>之二·2009年赴杭</p>
<p>五月远京城，往此寻高人。<br>
冰杯小作难，唤我掩柴门。<br>
晨作于西湖，暮归在古墩。<br>
筷头还肉香，竹园正新笋。</p>
</blockquote>
<p>又例如曾经在北京红叶拾楠偶得的一首：</p>
<blockquote>
<p>补闲·2014年秋于红叶拾楠</p>
<p>一杯薄水酬清客，碎雨寥落蕴书香。<br>
侧帽依稀知容若，老气将来喟秋长。</p>
</blockquote>
<p>说起这篇补闲，倒也是挺有趣的。在多年之后，我偶然打开闲置很久的Skype，突然在签名档上看到这句“侧帽依稀知容若，老气将来喟秋长”，觉得极好、极趁心情，于是就拿来做了微博的新签名。但一直又想知道这句诗的出处，查了许多次之后，终于还是在微博上搜到这首诗：原来就是自己写的。只是时间隔了三两年，便忘掉了。这件趣事记在这里：</p>
<ul>
<li><a href="http://weibo.com/1620925974/DwLaStwPF">http://weibo.com/1620925974/DwLaStwPF</a></li>
</ul>
<p>像这样在微博上发的东西真是既容易丢，也不连贯。例如我曾经写过一段配图的心情文字：</p>
<blockquote>
<p>我常常回顾自己。例如写字，文字好，但骨子里没东西。如果是书，文字感不强了，但知识总归是有些的。外在的东西花花绿绿的好看了，本质是内地里没东西需要拿些色彩抹在外面。修行的看不见菩萨，拜佛的不过对着一尊彩俑，很多事，就这么一眼眼地看着自己，渐渐地也就看明白了。</p>
</blockquote>
<p><img src="http://aimingoo.github.io/content/images/2017/10/609d5e16gw1f3nytor4vuj20c80hadgj.jpg" alt="609d5e16gw1f3nytor4vuj20c80hadgj"></p>
<p>事实上这图并不是我的，也原本不是用来配这段文字的。它的出处更早是在“国学论坛”上面，当时有网友发出来，我觉得喜欢，便写了一首诗：</p>
<blockquote>
<p>疏竹三竿瘦，青莲半粒苦。<br>
彩鲤影若在，小僧法相无。</p>
</blockquote>
<p>没想到网友读不明白，因了“小僧法相无”这一句而觉得这首诗是在讲“画得不好”。于是，我又再写了一篇文字来讲：</p>
<blockquote>
<p>这四句诗，有四件物事是诗中有，而画中实不存有的：</p>
<ul>
<li>三竿堪可数，青莲几曾苦；影子须弥在，法相有亦无。</li>
</ul>
</blockquote>
<p>所以这是禅诗的写法：诗与悟在。而且这首诗还进一步地讲了四个意思，是“诗”中说有，而“觉”中实无的：</p>
<blockquote>
<p>有形的（瘦）其实无形；<br>
有味的（苦）其实无味；<br>
有色的（彩）其实无色；<br>
有相的（法）其实无相。</p>
</blockquote>
<p>这便是在讲佛家的觉识了。是所谓相中有的，正是没有；相中没有的，正是有。有与没有，其实在这相中，皆是不要紧的。因为此相的有无，尽在观相的看客，而不在持相的诗画。</p>
<h2 id="">早些年</h2>
<p>除了写些这种不打紧的，我偶尔写些与麦子（Joy）相关的诗文。最早的一首词，是刚刚认识的时候写的：</p>
<blockquote>
<p>《如梦令·一剪梅》</p>
<p>是夜月色无华，雾霭轻扬如画。<br>
悠然笛声下，几度欲归还罢。<br>
无它，无它，深冬一剪梅花。</p>
</blockquote>
<p>当时还写了一首“绝黛”，想来也是为麦子写的，只是时间太久，记不真切了😜：</p>
<blockquote>
<p>《如梦令·绝黛》</p>
<p>素面无需铅华，蛾眉谁人能画，<br>
踟躇窗篱下，笺满难把笔罢。<br>
愁煞，愁煞，伤春何必梨花。</p>
</blockquote>
<p>早些年我的诗词风格是比较苦情的，婉约而清薄。后来阅历丰富了，文字上就沉稳了许多，即便仍是写伤情哀怨的，也不会像上面这样。例如曾经麦子发了一篇朋友圈，是一张照片，画面很简单的：只是高挑的檐角上，站着一只孤伶伶的麻雀。于是我拟了一首古风来配：</p>
<blockquote>
<p>天湛湛兮，沧沧如幕；羽习习兮，沾尘带露。<br>
是趁闲时，悄停梁户；或当花前，暗窥妆妇？<br>
稍息止兮，复往何处？君已远兮，惟我凄伫。</p>
</blockquote>
<p>看来这点写诗的底子用在现在，便也只能够为日常中的一些小事写写了。呵呵~</p>
<h2 id="">山水风景</h2>
<p>之前与麦子同学都很爱户外。有旅行计划不成的，写一首：</p>
<blockquote>
<p>无题·于2000年</p>
<p>短桥还正往，行步却已迟。春色稍纵逝，游者当择期。</p>
</blockquote>
<p>玩得高兴的，也来一首：</p>
<blockquote>
<p>无题·2005.01.18, 因妻游云台禅寺作</p>
<p>雪夜听禅声，驴步入云台。一念别尘嚣，千钟见太白。</p>
</blockquote>
<p>有些候玩得馋了也可能写一首哦（呵呵，这是<a href="http://aimingoo.github.io/59e2e9b272c9e7b37c3831f0">《深夜食味记》</a>系列中的）：</p>
<blockquote>
<p>无题·2016.02.13 于悉尼</p>
<p>吞津饥渴甚，离乡肚腑哀。思味至夜深，奈何无良材。</p>
</blockquote>
<p>多数短诗是用来配麦子同学发的照片的（当然也有长篇成组的，例如这里的<a href="http://aimingoo.github.io/59e709901bc77603d060b9af">诗写江南之行</a>）：</p>
<blockquote>
<p>蜂蝶轻舞处，青绿破土时。沉香知梅绛，新妆映哪枝？</p>
</blockquote>
<p>而最新近的，大概是一首词（写的是张衡路上的张衡公园）：</p>
<p><img src="http://aimingoo.github.io/content/images/2017/04/IMG_0826.JPG" alt="IMG_0353"></p>
<blockquote>
<p>虞美人影</p>
<p>草熏风暖花秀蕊，忽忽一夜春归。云色青青若醉，还与东湖寐。<br>
闲庭信步语声脆，依稀当时初会。贪看莺莺燕燕，又劳佳人催。</p>
</blockquote>
<p>其中这一句“云色青青若醉，还与东湖寐”，就是我在博客中的签名档的由来了。</p>
<h2 id="">新体诗</h2>
<p>看起来好象全是旧体诗词呢！</p>
<p>我确实是喜欢古文多一些，连麦子都说我看起来像个夫子。不过也并不是说我就不写新体诗，比如早些年有写过一首《关于永恒》。之所以会提到它，是因为我在《石像的忆述》之后便基本不写这类文字了，这是少有的例外（1999年）：</p>
<pre><code class="language-nohighlight">《关于永恒》

夜的黑是永恒的吧
我想

我回头看看冰冷的砖墙
漠然 地面对着这黑夜的深处
砖墙显得很完美
被抹得很平也很光滑

砖墙也应该很坚实吧
我想
因为我的脊梁靠着它冷冰的胸膛
砖墙也应该是有生命的吧
我想
因为我的脊梁能感觉到一颗还在搏动的心脏

我倚着这样一道冷漠的墙
在暗夜的街道上
我听见远方的禅钟悠悠敲响
我看见有过往的情侣如同燧石将黑夜擦亮
我知道街道的尽头不是家也不是超级市场

一只很小的蜘蛛很久很久前就在这街灯的顶上织着一张很小的网

我伸手拂了拂裤脚上干裂的泥浆
我回转身去将身体贴紧砖墙
我轻轻地将唇痕留在这堵墙上

砖墙也应该是会流泪的吧
蜷在墙根下
我这样想着
等着天亮
</code></pre>
<p>之后应该再没写过了罢？</p>
<p>想想，好象也不全对，应该是还有一首的（2009年）：</p>
<pre><code class="language-nohighlight">《要有光》

我一直在寻求尽头，
或展望于将来，
或求源于过往。

我在一道大河的中间，
前后观望，
时而俯首所得的，
不过是一掬破碎的倒影。

倒影中，还是我的迷惘。
</code></pre>
<p>不过它并不是一首独立的诗。它事实上是我的那本《JavaScript语言精髓与编程实践》在发布电子版的时候写的序（中的一部分）。这篇序是“世界需要一种什么样的语言”，它也被节选到“语言精髓”这本书的第二版的序中。——不过节选的时候，正好删除了这段文字，所以大多数读者便不知道了。</p>
<p>原文其实只是一段文字（<a href="http://aimingoo.github.io/1-135">在这里</a>），但排成长短句之后，竟然也如诗一般可读。😛</p>
<h2 id="">其它</h2>
<p>嗯，说起来，麦子也偶尔会写新体诗哦！</p>
<ul>
<li>在这里：<a href="http://aimingoo.github.io/2-34">狗，屎，运</a></li>
</ul>
<p>哈哈哈~~</p>
<h3 id="appendat20180427"><strong>append at 2018.04.27</strong></h3>
<h4 id="">之一</h4>
<p>在2012年离开支付宝时，曾作一首：</p>
<blockquote>
<p>无题·2012年离杭</p>
<p>四海为家中原客，行来方知所得空。<br>
莫向前程问三载，半作书生半作工。</p>
</blockquote>
<p>这首诗写的时候并没有多想，未料后来三数年，真是“半作书生半作工”。它后来也做了我在oschina以及知乎（等等一些我不太常去的网站）的签名。</p>
<p>诗中的“中原客”并非指我是河南人，而是说我这些年四处飘泊，家虽然安在郑州，却也如做客一般。我原是四川人一枚来着。</p>
<h4 id="">之二</h4>
<p>在2016年11月时，曾有一首谐趣的古风写在朋友圈里：</p>
<blockquote>
<p>无题·2016年11月于京城</p>
<p>麦子约帅哥于浦西兮，吾独酌于都朝。<br>
叹门前风卷薄雪兮，吾瑟瑟而悯悼。<br>
素酒三温复凉兮，吾归心如飞矢。<br>
疾兮，迅兮，期期而不至。</p>
</blockquote>
<p>这段其实是打趣的，当时麦大老板约老友王大发财于浦西饭局，而我正好在北京吃着火锅看着雪。:)</p>
<h4 id="">之三</h4>
<ul>
<li>在上面写“诗写江南之行”的时候，当时写到<a href="http://aimingoo.github.io/59e709901bc77603d060b9af/#%E8%B6%A3%E8%88%8D%C2%B7%E6%83%9C%E8%A7%81%E9%BE%99%E8%83%8C%E5%B1%B1%E6%96%87%E5%B3%B0%E5%A1%94">夜宿“一棵树”的诗句</a>：雨过泉声至，风起竹涛还。因为每日的诗句都是配了图发在朋友圈里的，所以便有好友gurudk在下面写道：</li>
</ul>
<blockquote>
<p>雨中听泉，茶道寻芳，诗书作伴，美人相陪，美</p>
</blockquote>
<p>本也不过是他的赞叹而已。而我是一时兴起，四句各加了一字，伪作古人，回给了gurudk：</p>
<blockquote>
<p>雨中听泉落，茶道寻芳归。诗书勤作伴，美人时相陪。<br>
《绝句.归田乐》——宋.时轶名</p>
</blockquote>
<p>没想到那时真骗到了gurudk~ 哈哈。</p>
</div>]]></content:encoded></item><item><title><![CDATA[诗写江南之行]]></title><description><![CDATA[<div class="kg-card-markdown"><blockquote>
<p><em>原作于2017.04.16发于微信朋友圈</em></p>
</blockquote>
<p>跟麦子同学策划了一次无计划的江南之行，从4.6~4.15，自上海经苏州、湖洲、宜兴、南京，最后从镇江回到上海。去年游澳大利亚时，便趁着得了空闲，写了一组『深夜食味记』，那是散文。这次亦然，不过换成了古体诗。</p>
<p>这次写法有些特别。在习惯上每日只写两句，写一时之所想，在用韵、平仄这些方也并不特别讲究。十日后掇句而成诗，不求同题同义，只求上下合仄押韵、诗趣暗合，如此一来还真算是写了几首。不过取诗题的时候有些麻烦，因此简简单单地用『·』号隔了，表示这诗原是两段而已。当然也有几首是一次写成的，合在一起，算作了这次的游记。</p>
<h2 id="">平江·午后得闲</h2>
<p><img src="http://aimingoo.github.io/content/images/2017/04/IMG_0332.JPG" alt="IMG_0332"></p>
<p><img src="http://aimingoo.github.io/content/images/2017/04/IMG_0353.JPG" alt="IMG_0353"></p>
<blockquote>
<p>烟雨入苏杭，春色只平江<sup>①</sup><br>
斑斓三两点，珠玉正琳琅</p>
<p><sup>①</sup><em>平江：指平江路，沿苏州平江河的一条小路，历史老街。</em></p>
</blockquote>
<p>前两句既写我们到苏杭闲游之实，也写当时的阴雨天气；平江之美，</p></div>]]></description><link>http://aimingoo.github.io/59e709901bc77603d060b9af/</link><guid isPermaLink="false">59e709901bc77603d060b9af</guid><category><![CDATA[诗词文章]]></category><category><![CDATA[生活]]></category><category><![CDATA[旅游]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Wed, 18 Oct 2017 08:38:23 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><blockquote>
<p><em>原作于2017.04.16发于微信朋友圈</em></p>
</blockquote>
<p>跟麦子同学策划了一次无计划的江南之行，从4.6~4.15，自上海经苏州、湖洲、宜兴、南京，最后从镇江回到上海。去年游澳大利亚时，便趁着得了空闲，写了一组『深夜食味记』，那是散文。这次亦然，不过换成了古体诗。</p>
<p>这次写法有些特别。在习惯上每日只写两句，写一时之所想，在用韵、平仄这些方也并不特别讲究。十日后掇句而成诗，不求同题同义，只求上下合仄押韵、诗趣暗合，如此一来还真算是写了几首。不过取诗题的时候有些麻烦，因此简简单单地用『·』号隔了，表示这诗原是两段而已。当然也有几首是一次写成的，合在一起，算作了这次的游记。</p>
<h2 id="">平江·午后得闲</h2>
<p><img src="http://aimingoo.github.io/content/images/2017/04/IMG_0332.JPG" alt="IMG_0332"></p>
<p><img src="http://aimingoo.github.io/content/images/2017/04/IMG_0353.JPG" alt="IMG_0353"></p>
<blockquote>
<p>烟雨入苏杭，春色只平江<sup>①</sup><br>
斑斓三两点，珠玉正琳琅</p>
<p><sup>①</sup><em>平江：指平江路，沿苏州平江河的一条小路，历史老街。</em></p>
</blockquote>
<p>前两句既写我们到苏杭闲游之实，也写当时的阴雨天气；平江之美，可以一赞。</p>
<p>后两句中，上句是写一天以后游苏州工艺美术博物馆，却没写藏品和观感。当时博物馆中只有廖廖数人，我与麦子在林荫处倚栏无语，斑斓地红叶天，是安静所在。下句的『珠玉正琳琅』，却是写我们随后去了不远处的苏州博物馆，参观『玉叶金枝——明代江西藩王墓出土文物精品展』。用一『正』字，是错开时空，上一句的寻幽取静，与下一句的琳琅满目对照，是『蝉噪林愈静』的写法。</p>
<h2 id="">游苏州美人腿</h2>
<p><img src="http://aimingoo.github.io/content/images/2017/04/IMG_0338.JPG" alt="IMG_0338"></p>
<p><img src="http://aimingoo.github.io/content/images/2017/04/WechatIMG1139_1.jpg" alt="WechatIMG1139_1"></p>
<blockquote>
<p>黄花濯雨娇，玉足春寒薄<sup>①</sup><sup>②</sup><br>
眉黛藏秀色，青丝起妖娆</p>
<p><sup>①</sup><em>黄花：油菜花。时小雨初歇，雨气未尽，春寒绵绵。</em><br>
<sup>②</sup><em>玉足：指美人腿。美人腿是地名，且名如其形，确是玉足纤纤。</em></p>
</blockquote>
<p>前两句说的是雨后春寒的风景。后两句写的是麦子。</p>
<p>麦子同学最喜欢油菜花，所以那天的朋友圈我也就发了一整首诗。</p>
<h2 id="">趣舍·惜见龙背山文峰塔</h2>
<p><img src="http://aimingoo.github.io/content/images/2017/04/IMG_0340.JPG" alt="IMG_0340"></p>
<p><img src="http://aimingoo.github.io/content/images/2017/04/WechatIMG1146.jpeg" alt="WechatIMG1146"></p>
<blockquote>
<p>雨过泉声至，风起竹涛还<br>
文峰轻晚客，烟柳落纸鸢<sup>①</sup><sup>②</sup></p>
<p><sup>①</sup><em>文峰：指文峰塔，位于宜兴龙背山森林公园，有『文峰夕照』之景。</em><br>
<sup>②</sup><em>轻：轻慢。</em></p>
</blockquote>
<p>前两句是写我们十日于『趣舍·一棵树』夜宿。到达时正在下雨，而这家民宿是借山成壁，因此屋外下雨，则室内生泉。坐在大厅品茶，便可听耳旁叮咚轻响，雨声渺而泉声近。整个建筑倚于竹林之下，风起如涛，风止无声。</p>
<p>后两句是十一日写于宜兴，游龙背山森林公园。写我们到得晚了，既未看得『文峰夕照』之景，连风筝都已经放过了，依稀有一些落在柳树上，破落寂廖。所以当日在微信发圈时有写：</p>
<blockquote>
<p>时至春暮，倒寒愈盛，坐想被时光轻慢的我们，又何曾辜负过风景。</p>
</blockquote>
<h2 id="">碧鲜庵·苏州园林所见</h2>
<p><img src="http://aimingoo.github.io/content/images/2017/04/IMG_5389_1.jpg" alt="IMG_0344_1"></p>
<p><img src="http://aimingoo.github.io/content/images/2017/04/WechatIMG1148.jpeg" alt="WechatIMG1148"></p>
<blockquote>
<p>溪桃夜听碧，林竹入目鲜<sup>①</sup><sup>②</sup><br>
时有小去处，不见真湖山</p>
<p><sup>①②</sup><em>碧、鲜：指碧鲜庵。善卷洞风景区内有碧鲜庵，曾为英台读书处。</em></p>
</blockquote>
<p>前两句是十二日游善卷洞，写于碧鲜庵前。庵前小溪边桃花纷纷，至远处，竹林层层。然则碧色岂可耳听，竹鲜哪能目视？斯若听者，斯若视者，惟心下念念耳。</p>
<p>后两句写的是七日我游拙政园和定园后，对苏州园林的观感。说是造景借景、假山假水，实则格局太狭，难得张狂而已。一步画廊半坡桥，小之甚也。</p>
<h2 id="">玄武湖·中山寻芳步道</h2>
<p><img src="http://aimingoo.github.io/content/images/2017/04/IMG_0347.JPG" alt="IMG_0347"></p>
<p><img src="http://aimingoo.github.io/content/images/2017/04/WechatIMG1145.jpeg" alt="WechatIMG1145"></p>
<blockquote>
<p>湖畔驻千舟，庭中挂紫藤<sup>①</sup><sup>②</sup><br>
轻风胡不住，斜阳照半亭</p>
<p><sup>①</sup><em>湖畔：指玄武湖，南京市东郊有玄武湖，其北有明城墙、钟山。</em><br>
<sup>②</sup><em>庭中：玄武湖台菱堤有花架七曲，若庭若廊，『台菱花架』一景是也。</em></p>
</blockquote>
<p>前两行写玄武湖景观。千舟不发，紫藤轻挂，静若动也。</p>
<p>后两行是次日游中山植物博览园所写。风轻不停，夕照影移，动亦静尔。</p>
<h2 id="">游中山植物园</h2>
<p><img src="http://aimingoo.github.io/content/images/2017/04/WechatIMG1143.jpeg" alt="WechatIMG1143"></p>
<p><img src="http://aimingoo.github.io/content/images/2017/04/WechatIMG1142.jpeg" alt="WechatIMG1142"></p>
<blockquote>
<p>寻香入花海，佳人巧笑频<br>
湖水漫半堤，林荫没短亭</p>
</blockquote>
<p>麦子说中山植物园（植物博览园）是此行她最喜欢的去处之一，这时节郁金香开得正盛，满园花香。园中有湖，名曰前湖，时湖水漫堤，林深掩亭，各成景致。</p>
<h2 id="">归客·游西津渡</h2>
<p><img src="http://aimingoo.github.io/content/images/2017/04/IMG_0350.JPG" alt="IMG_0350"></p>
<p><img src="http://aimingoo.github.io/content/images/2017/04/IMG_0352.JPG" alt="IMG_0352"></p>
<blockquote>
<p>肴肉留客驻，待渡亭下空<sup>①</sup><sup>②</sup><br>
日落千帆尽，谈笑大江东</p>
<p><sup>①</sup><em>肴肉：一种本地美食，本地人将『肴』字读作xiao（音『肖』）。</em><br>
<sup>②</sup><em>待渡亭：西津渡渡口有亭一座，供路人小憩，等待摆渡的场所。</em></p>
</blockquote>
<p>前面说『不舍去』，后面写『君去也』。15日于镇江，上午游镇江西津渡，下午则返回上海浦东。一日三两地，游者终有期。</p>
<p>后两句既是虚写长江上当年日落挥别、谈笑作揖的情景，也是暗指我跟麦子回上海了也。^^.</p>
</div>]]></content:encoded></item><item><title><![CDATA[手记7：从单人博客到多人博客全程记录]]></title><description><![CDATA[<div class="kg-card-markdown"><blockquote>
<p>上一篇手记是讲“改造Gitment”的(<a href="http://aimingoo.github.io/1-1725">在这里</a>)。其实这个“改造”花了不少功夫，以至于后来还出了一个给<code>hexo-theme-next</code>的版本。</p>
<p>这是推迟了“做多人博客”的一个原因，另一个原因则是我以前的博文需要更新的太多，花了很多时间。当然，那个叫<code>Monster</code>的项目（<a href="http://aimingoo.github.io/1-1741">在这里</a>）也是花销时间的大户。</p>
<p>所以，结果就是：这篇“手记7”被推迟了很久...很久...</p>
</blockquote>
<p>多人博客的功能其实我一早就做出来了——至少，大概的框架是完成了的。但是我一直没有发布出来，“<a href="http://aimingoo.github.io/author/joyxhy">麦秸的垛</a>”也就一直没上线。</p>
<p>下面讲讲这整个的过程。</p>
<h2 id="">导入“第二个人”的博客文章</h2>
<p>在Ghost 0.9x中其实有一个Bug，就是你总是只能将博客导入到'id=1'的帐户（或以该帐户身份导入）。我说不清这个Bug是什么时候存在，又或者（可能）什么时候会修复/已修复。我当时找到的解决方法，就是直接改sqlite数据库。</p></div>]]></description><link>http://aimingoo.github.io/59e452a9bc4c6b0274b469a9/</link><guid isPermaLink="false">59e452a9bc4c6b0274b469a9</guid><category><![CDATA[博客]]></category><category><![CDATA[OpenSource Project]]></category><category><![CDATA[Monster]]></category><category><![CDATA[Ghost]]></category><category><![CDATA[Javascript]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Mon, 16 Oct 2017 15:41:58 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><blockquote>
<p>上一篇手记是讲“改造Gitment”的(<a href="http://aimingoo.github.io/1-1725">在这里</a>)。其实这个“改造”花了不少功夫，以至于后来还出了一个给<code>hexo-theme-next</code>的版本。</p>
<p>这是推迟了“做多人博客”的一个原因，另一个原因则是我以前的博文需要更新的太多，花了很多时间。当然，那个叫<code>Monster</code>的项目（<a href="http://aimingoo.github.io/1-1741">在这里</a>）也是花销时间的大户。</p>
<p>所以，结果就是：这篇“手记7”被推迟了很久...很久...</p>
</blockquote>
<p>多人博客的功能其实我一早就做出来了——至少，大概的框架是完成了的。但是我一直没有发布出来，“<a href="http://aimingoo.github.io/author/joyxhy">麦秸的垛</a>”也就一直没上线。</p>
<p>下面讲讲这整个的过程。</p>
<h2 id="">导入“第二个人”的博客文章</h2>
<p>在Ghost 0.9x中其实有一个Bug，就是你总是只能将博客导入到'id=1'的帐户（或以该帐户身份导入）。我说不清这个Bug是什么时候存在，又或者（可能）什么时候会修复/已修复。我当时找到的解决方法，就是直接改sqlite数据库。</p>
<p>不过自从我开始启用Ghost 1.x之后，这个担忧就没有了。在多人博客这个问题上，Ghost 1.x做得其实更好，所以我后面也是在用这个版本，关于0.9x的更多细节就不谈了。</p>
<p>假如你已经有了一个基于Ghost的本地博客，已经有一个帐户了，那么当你需要把它变成“多人博客”时，你自然需要再创建一个帐户——这个不用多说了。一旦你搞定了，那么你可以用monster来查询到多个用户的信息：</p>
<pre><code class="language-bash">&gt; monster list user
id                        name        slug        email         
------------------------  ----------  ----------  --------------
1                         aimingoo    aimingoo    aiming@gmail.com 
5951f5fca366002ebd5dbef7  second      new-user    ...
...
</code></pre>
<p>记下新用记的<code>id</code>值（5951f5fca366002ebd5dbef7），后面我们会用到。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>在Monster v1.0.7以下的版本中<code>list user</code>只会显示被截断的user id。因此要正确地查询这个<code>id</code>值，请将你的Monster升级到<code>v1.0.7</code>或更高版本——或者你也可以自己打开sqlite数据库查看。</p>
</blockquote>
<p>接下来，假设你是用BlogToWordpress来迁移的博客，那么你会有一个wordpress格式的.xml文件，存放用户second的全部博客——如果你是用别的来导出，那么请转换到wordpress格式先。参考：</p>
<ul>
<li><a href="http://aimingoo.github.io/1-1719">手记1：迁移博客之全程工具</a></li>
</ul>
<p>我们将这个.xml用工具wp2ghost转换到ghost-tmp.json，然后再使用putrefy.js来处理一次，得到最终的ghost.json就可以了。这个过程参考：</p>
<ul>
<li><a href="http://aimingoo.github.io/1-1719/#22-%E5%87%86%E5%A4%87%E5%AF%BC%E5%85%A5%E6%96%87%E4%BB%B6">准备导入文件</a></li>
</ul>
<p>但还是要注意以下几点：</p>
<h3 id="wp2ghost">使用修改版的wp2ghost</h3>
<p>你可以考虑使用我的修改版wp2ghost。主要有三处变化：</p>
<ul>
<li>tag忽略大小写</li>
<li>忽略掉总是存在的DefaultCategory这个tag</li>
<li>兼容用<code>wp:wp_author</code>和<code>wp:author</code>来识别作者名</li>
</ul>
<p>下载在这里：</p>
<ul>
<li><a href="https://github.com/aimingoo/wp2ghost">https://github.com/aimingoo/wp2ghost</a></li>
</ul>
<h3 id="putrefyjs">配置putrefy.js</h3>
<p>如果你只是简单导入，那么你可以直接使用putrefy.js命令行传入Ghost用户的id值（上面找到的那个）。例如：</p>
<pre><code class="language-bash"># 获取 putrefy.js
&gt; curl -L https://github.com/aimingoo/ghost-utils/raw/master/putrefy.js -o putrefy.js

# 处理ghost-tmp.json
&gt; node putrefy.js ghost-tmp.json '5951f5fca366002ebd5dbef7' &gt; ghost.json
</code></pre>
<p>不过注意，很多情况下putrefy.js不是直接使用的，它<code>几乎总是</code>需要修改配置才能使用（除了上面的这个new_author_id参数外，就只能直接修改源代码了）。</p>
<p>最后，参考上面的博客说明，你应该可以顺利地用putrefy.js了。</p>
<h3 id="">多博客的一点说明</h3>
<p>在使用putrefy.js时，它缺省为你的post生成的slug将是<code>authorId-postId</code>格式的，例如上面的<code>5951f5fca366002ebd5dbef7</code>，就会生成<code>5951f5fca366002ebd5dbef7-1</code>..<code>...-n</code>这样的格式。</p>
<p>你可以改这个缺省值改成特定风格。例如<code>2-</code>，或者<code>myblog:</code>这样的前缀。这需要直接修改putrefy.js源代码中的<code>SLUG_FROMID</code>变量值。如下：</p>
<pre><code class="language-javascript">## 参数值：
##   - &quot;字符串&quot;: 以postId作为slug，并将该字符串值直接作为前缀
##   - true: 以postId作为slug，并用当前的&quot;authorId-&quot;作为前缀，authorId值缺省为1
##   - false: 不修改slug

SLUG_FROMID=&quot;2-&quot;
</code></pre>
<p>另外，某些情况下，从wordpress格式的.xml文件中导出的authorId值不总是缺省值1（或者可能因为意外的缘故就没有authorId值），这种情况下，你需要修改putrefy.js代码中的</p>
<pre><code class="language-javascript">var author_map = {
  &quot;1&quot;: ...
}
</code></pre>
<p>它可以处理多个authorId，或强制指定转换表。</p>
<h2 id="ghost">在你的Ghost模板中识别多个作者</h2>
<p>有两种方法来识别多个作者。</p>
<p>第一种是直接在模板中使用<code>{{author}}</code>，这个标签对于author、page和post等页都是有效的，因此可以方便地使用这个标志来为不同作者切换内容：</p>
<pre><code class="language-html">&lt;!-- 可以直接用`{{#has ...}`来识别 --&gt;
{{#has author=&quot;aimingoo, qomo&quot;}}
 ....
{{/has}}
</code></pre>
<p>但是这不能作用于<code>{{&gt; ..}}</code>标签来装载的子模板——你当然可以写多个<code>has</code>来识别，但这并不方便。因此，我在博客中选择了第二种方案：通过加载<code>&lt;script&gt;</code>标签来处理。</p>
<p>这个名为<code>author-switch.js</code>的脚本在这里：</p>
<ul>
<li><a href="https://github.com/aimingoo/aimingoo.github.io/blob/master/assets/js/author-switcher.js">https://github.com/aimingoo/aimingoo.github.io/blob/master/assets/js/author-switcher.js</a></li>
</ul>
<p>可以通过如下的方式来加载：</p>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot; author=&quot;{{author.slug}}&quot; src=&quot;/assets/js/author-switcher.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>或</p>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot; author=&quot;default&quot; src=&quot;/assets/js/author-switcher.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>在<code>author-switcher.js</code>中会读取所有scripts并查找到这个标签，然后从标签中取出<code>author</code>属性，并针对不同的author来处理当前页面的显示——基本上就是调整导航栏、标题页等等。</p>
<p><code>author-switcher.js</code>中有部分代码显得比较复杂，主要是根据deviceWidth来处理导航栏显示的（用于适应手机等窄屏设备）。</p>
<blockquote>
<p><strong>你不能直接使用<code>author-switcher.js</code>，它需要根据你的网站定制</strong></p>
</blockquote>
<h2 id="">静态页的处理</h2>
<p>一些静态页是多个作者之间不同的，例如A作者可以显示某些标签，而B作者就不需要（你想想如果在麦秸的垛的文章里显示出JavaScript这样的标签会是什么效果）。因此我除了将tag-cloud等页面静态化（处理方法<a href="http://aimingoo.github.io/1-1721/#72-%E5%B0%86%E7%AB%99%E7%82%B9%E4%BF%A1%E6%81%AF%E4%B8%8E%E4%BA%91%E6%A0%87%E7%AD%BE%E9%9D%99%E6%80%81%E5%8C%96">在这里</a>）之外，也在其中加入了相应的代码来处理这种静态页内的信息。例如：</p>
<pre><code class="language-html">&lt;!-- in page-tag-cloud.hbs --&gt;

var enabledCloudTags = {
    'default': 'all',
    'aimingoo': 'all',
    'more users': [ &quot;some tags for other', ...]
}

function filterByAuthor(context, enabled) {
    if (enabled == 'all') return context;
    ...
}
</code></pre>
<p>相应的代码在这里：</p>
<ul>
<li><a href="https://github.com/aimingoo/aimingoo.github.io/blob/master/tag-cloud">https://github.com/aimingoo/aimingoo.github.io/blob/master/tag-cloud</a></li>
</ul>
<blockquote>
<p><strong>注意其中的cloudTagHtmlContext()内的代码是由标签<code>{{&gt; &quot;tag_cloud&quot;}}</code>自动生成的，参考：'7.2.1 为标签云添加一个静态页' @<a href="http://aimingoo.github.io/1-1721">这里</a></strong></p>
</blockquote>
<h2 id="thread">多作者多线索（Thread）</h2>
<p>Ghost缺省的多作者模式是“多作者单线索”的，也就是所有作者的<code>prev/next</code>是在同一个list中，这样A作者的上/下一篇日志，就可能是B作者的。对于同一主题的博客（例如相同兴趣的网站）来说这没问题，但是我跟Joy的博客风格差异很大，你想想在一篇讨论户外驴友美食或化妆的文章中出现“上一篇”是某个开源程序项目的……效果，那真的是……</p>
<p>好吧。所以我需要跟Joy的博客使用“多作者多线索”的风格。这个是早先的Ghost版本中是不支持的，因为它默认的prev/next helper是只支持单线索的。这个问题已经被提了两年了……没解决过。</p>
<p>很幸运的事情是，正好在“麦秸的垛”上线前一两天，Ghost v1.14.0发布了。这个版本中带了一个<code>primary tag</code>的特性，它的实现方案令人眼前一亮啊（呵呵）。“多作者多线索”的实现立即变得简单了，于是我加了几行代码，现在你可以在<code>post.hbs</code>里这样写：</p>
<pre><code class="language-html">{{! -- MUST include &quot;author&quot; field -- }}
{{#get &quot;posts&quot; filter=&quot;id:{{id}}&quot; include=&quot;author&quot; as |current|}}
{{#current}}

  {{#prev_post in=&quot;author&quot;}}  ...
  ...

  {{#next_post in=&quot;author&quot;}} ...
  ...

{{/current}}
{{/get}}
</code></pre>
<p>就可以了。——注意其中的<code>include=&quot;author&quot;</code>和<code>in=&quot;author&quot;</code>。</p>
<p>这个简单的feature已经提交到Ghost team了（<a href="https://github.com/TryGhost/Ghost/pull/9149">在这里</a>），如果你等不及的话也可以直接用我fork的版本：<a href="https://github.com/aimingoo/Ghost/tree/prev-next-author">https://github.com/aimingoo/Ghost/tree/prev-next-author</a></p>
</div>]]></content:encoded></item><item><title><![CDATA[Monster 1.0.6开启的新功能]]></title><description><![CDATA[<div class="kg-card-markdown"><h2 id="">多人博客</h2>
<p>经过几个版本的更新，Monster已经开始有了丰富的功能，这其中就包括对Ghost多人博客的支持。</p>
<p>Monster主要是在<code>updatesite.sh</code>模式中支持多人博客，也就是说这个功能在<code>update</code>模式下可用。当在<code>.monster</code>配置文件的<code>EMAIL</code>参数中使用一个列表，例如：</p>
<ul>
<li><code>EMAIL=(&quot;aiming@gmail.com&quot; &quot;qomo@gmail.com&quot;)</code></li>
</ul>
<p>那么多人博客的模式就自动开启，并在<code>--sync-removed</code>命令中有效。</p>
<blockquote>
<p>注：如果你只是删除post，或更新theme中post的风格，那么由于<code>update</code>模式无法从数据库感知到你的更新，所以就需要使用<code>--sync-removed</code>来强制更新指定用户/多个用户的博客内容。一旦使用该命令，那么也将导致整个的索引页会强制更新（因为上面的操作事实上也意味着全站的posts index pages页发生了变化）</p>
</blockquote>
<h2 id="pages">可定制强制更新的pages列表</h2>
<p>当使用<code>update</code></p></div>]]></description><link>http://aimingoo.github.io/59e22d961369c498d686e75c/</link><guid isPermaLink="false">59e22d961369c498d686e75c</guid><category><![CDATA[博客]]></category><category><![CDATA[OpenSource Project]]></category><category><![CDATA[Monster]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sat, 14 Oct 2017 17:36:43 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><h2 id="">多人博客</h2>
<p>经过几个版本的更新，Monster已经开始有了丰富的功能，这其中就包括对Ghost多人博客的支持。</p>
<p>Monster主要是在<code>updatesite.sh</code>模式中支持多人博客，也就是说这个功能在<code>update</code>模式下可用。当在<code>.monster</code>配置文件的<code>EMAIL</code>参数中使用一个列表，例如：</p>
<ul>
<li><code>EMAIL=(&quot;aiming@gmail.com&quot; &quot;qomo@gmail.com&quot;)</code></li>
</ul>
<p>那么多人博客的模式就自动开启，并在<code>--sync-removed</code>命令中有效。</p>
<blockquote>
<p>注：如果你只是删除post，或更新theme中post的风格，那么由于<code>update</code>模式无法从数据库感知到你的更新，所以就需要使用<code>--sync-removed</code>来强制更新指定用户/多个用户的博客内容。一旦使用该命令，那么也将导致整个的索引页会强制更新（因为上面的操作事实上也意味着全站的posts index pages页发生了变化）</p>
</blockquote>
<h2 id="pages">可定制强制更新的pages列表</h2>
<p>当使用<code>update</code>模式时，如果一个置为<code>static page</code>的页面是使用动态生成方式来生成的——例如archive页，那么仍然是由于数据库不可感知的缘故，就需要使用<code>--force</code>参数来强制生成。你可以通过一个名为<code>FORCEPAGE_LIST</code>的参数来指定这些页面的列表，该参数也在<code>.monster</code>配置文件中。例如：</p>
<ul>
<li><code>FORCEPAGE_LIST=(&quot;archives-post-second-user/&quot;)</code></li>
</ul>
<p>在这个例子中，由于<code>/archives-post/</code>页总是动态生成的网站归档页，所以它缺省是被Monster内部处理的。但如果是使用多人博客（或者其它原因），那么可能就需要生成多个这样的归档。这“动态生成”就意味着从sqlite数据库中感知不到，所以就需要象上面这样强制定义列表。</p>
<p>与此类似的，由于<code>update</code>模式总是尝试使用short_path，因此缺省情况下会将类似<code>/about/index.html</code>这样的页面处理成<code>/about.html</code>。这在大多数情况下是适用的，但Ghost却默认会将导航栏上的链接转换成<code>/.../</code>这样的格式，也就是说它必须使用<code>/about/index.html</code>。这一类的问题在<code>update</code>模式时必须手工指定，你可以使用类似下面的配置：</p>
<ul>
<li><code>FORCEINDEX_LIST=(&quot;about-second-user&quot;)</code></li>
</ul>
<p>在使用Monster的<code>generate</code>模式时也会有这个问题，这是通过<code>IGNORE_LIST</code>来处理的。事实上<code>makesite.sh</code>模块会将这个列表与<code>FORCEINDEX_LIST</code>列表合在一起，来跳过所有不需要处理——亦即是将会保留index.html文件——的目录。</p>
<h2 id="">搜索功能</h2>
<p>Monster提供一种快速搜索的功能，这可以通过<code>monster search ...</code>来实现。</p>
<p>在Ghost 0.9x版本与1.x版本中的数据库结构并不相同，而Monster会自动识别并处理不同的查询条件。因此，现在开始，你可以简单的了解一下你的Posts中都有些什么了（Monster只搜索Posts的内文，而在Ghost Admin后台上搜索只处理标题）：</p>
<pre><code class="language-bash">&gt; monster search &quot;关键字&quot;
id        slug        created_at           title                                 
--------  ----------  -------------------  --------------------------------------
59dafc1a  1-44        2006-04-16 21:03:00  Qomo OpenProject beta1 精彩图集～
59dafc1a  1-50        2006-10-09 14:23:00  【原创】搞了个NetGear的路由?
...
</code></pre>
<h2 id="shortpath">短路径（Short Path）的规则</h2>
<p>在使用Ghost 0.9x时，数据库中的Post ID是从1开始的自增序的，因此Monster采用的short-path规则是<code>authorId-postId</code>。但从Ghost 1.x开始，数据库中的authrId和postId都不再是自增序的整数了，而是一个长的字符串（从旧数据库中导入的一些数据存在例外）。因此，即使使用Monster的<code>--short-path</code>参数，也无法按旧规则来生成这个名字。</p>
<p>因此从Monster 1.06开始，<code>update</code>模式下的<code>--sync-slug</code>会根据数据库版本来选择如下两种格式之一：</p>
<ul>
<li>在Ghost 1.x中采用<code>postId</code>作为post slug；</li>
<li>在Ghost 0.9x中采用<code>authorId-postId</code>作为post slug。</li>
</ul>
<p>考虑到从0.9x迁移到1.x的情况，<code>--sync-slug</code>不对已经采用了short-path格式的slug再做sync操作——了就是说0.9x已经使用了short-path的post会被忽略。<strong>但在识别这种情况时，只处理authorId&lt;9的情况</strong>，这在一般情况下是够用的。</p>
<h2 id="fastcommands">快速命令（Fast commands）</h2>
<p>Monster为一些常用命令建立了快速命令风格，例如上面的<code>monster search ...</code>。在这种风格中，<code>search</code>并不是一个模式——Monster目前只支持<code>generate/update/preview</code>三种模式。</p>
<p>事实上，<code>monster search ...</code>是等效于<code>monster update --search ...</code>的，从Monster v1.0.5开始就提供了这样的一种快速命令风格，用于简单地执行一些命令开关。虽然目前只有<code>search/list</code>两个，但将来会扩充它。</p>
<h2 id="posts">支持无限数量的Posts</h2>
<p>在早前的Monster脚本中只能处理有限数据的Posts，因为过多的Posts生成特别大的正则表达式，从而导致sed调用失效。在Monster v1.0.6中修正了这个Bug，使得Post会根据标题长度自动计算批次，分批处理，从而实现了对“无限数量”的Posts的支持。</p>
<h2 id="">其它</h2>
<p>Monster从v1.0.5开始就不再需要预先安装Buster了，所以它也不再依赖Python环境——如果你不使用<code>preview</code>功能的话。</p>
<p>你可以使用brew来快速安装Monster：<code>brew install aimingoo/repo/monster</code>。</p>
<p>也可以从Github下载Monster：<a href="https://github.com/aimingoo/monster">https://github.com/aimingoo/monster</a>。</p>
</div>]]></content:encoded></item><item><title><![CDATA[麦秸的垛 - 多人博客上线啦]]></title><description><![CDATA[<div class="kg-card-markdown"><p>麦子的文字写得比我好看，她的博客就叫“麦秸的垛”。</p>
<p>很早就说要把这个博客做成多人博客，其实也一早就做了，只是一直没上线。原因是从旧博客迁移过来的时候，几乎所有的文章都得再按markdown格式重排一遍。这个确实很花时间，比如我的那部分大概做了三个月呢。</p>
<p>所以“麦秸的垛”就一直拖着没上线。</p>
<p>麦子之前在新浪、搜狐和微软MSN上发的博文其实不少，我一次全迁移过来了，也是200多篇呢。所以接下来又得花阵子功夫来做排版了，不过应该会比我的快：毕竟她的博文没代码……</p>
<p>我的文字太硬气，读起来难以让人愉悦，麦子的不会。这个，相信我。</p>
<p>点右上方的链接就好了。</p>
</div>]]></description><link>http://aimingoo.github.io/59df7101a550c258f56eab34/</link><guid isPermaLink="false">59df7101a550c258f56eab34</guid><category><![CDATA[博客]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Thu, 12 Oct 2017 13:42:06 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>麦子的文字写得比我好看，她的博客就叫“麦秸的垛”。</p>
<p>很早就说要把这个博客做成多人博客，其实也一早就做了，只是一直没上线。原因是从旧博客迁移过来的时候，几乎所有的文章都得再按markdown格式重排一遍。这个确实很花时间，比如我的那部分大概做了三个月呢。</p>
<p>所以“麦秸的垛”就一直拖着没上线。</p>
<p>麦子之前在新浪、搜狐和微软MSN上发的博文其实不少，我一次全迁移过来了，也是200多篇呢。所以接下来又得花阵子功夫来做排版了，不过应该会比我的快：毕竟她的博文没代码……</p>
<p>我的文字太硬气，读起来难以让人愉悦，麦子的不会。这个，相信我。</p>
<p>点右上方的链接就好了。</p>
</div>]]></content:encoded></item><item><title><![CDATA[博客中的系列文章]]></title><description><![CDATA[<div class="kg-card-markdown"><h2 id="">【技术类】</h2>
<h3 id="qomo">Qomo技术系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-15/">从基础开始：Qomo OpenProject中的一些关键词</a></li>
<li><a href="http://aimingoo.github.io/1-16/">从基础开始：Qomo OpenProject中的一些关键词(2)</a></li>
<li><a href="http://aimingoo.github.io/1-18/">JavaScript面向对象的支持(1)</a></li>
<li><a href="http://aimingoo.github.io/1-21/">JavaScript面向对象的支持(2)</a></li>
<li><a href="http://aimingoo.github.io/1-22/">JavaScript面向对象的支持(3)</a></li>
<li><a href="http://aimingoo.github.io/1-23/">JavaScript面向对象的支持(4)</a></li>
<li><a href="http://aimingoo.github.io/1-24/">JavaScript面向对象的支持(5)</a></li>
<li><a href="http://aimingoo.github.io/1-26/">JavaScript面向对象的支持(6)</a></li>
<li><a href="http://aimingoo.github.io/1-27/">JavaScript面向对象的支持(7)</a></li>
<li><a href="http://aimingoo.github.io/1-30/">Qomolangma实现篇(一)：内核载入模块system.js的实现</a></li>
<li><a href="http://aimingoo.github.io/1-32/">Qomolangma实现篇(二)：命名空间和别名子系统的实现</a></li>
<li><a href="http://aimingoo.github.io/1-35/">Qomolangma实现篇(三)：兼容层设计</a></li>
<li><a href="http://aimingoo.github.io/1-36/">Qomolangma实现篇(四)：基本特性增强与多投事件系统</a></li>
<li><a href="http://aimingoo.github.io/1-38/">Qomolangma实现篇(五)：Qomo的OOP的语法和类继承体系</a></li>
<li><a href="http://aimingoo.github.io/1-39/">Qomolangma实现篇(六)：Qomo的OOP框架的实现技术</a></li>
<li><a href="http://aimingoo.github.io/1-42/">Qomolangma实现篇(七)：Qomo的接口机制</a></li>
<li><a href="http://aimingoo.github.io/1-43/">Qomolangma实现篇(八)：Qomo中的AOP框架</a></li>
<li><a href="http://aimingoo.github.io/1-47/">Qomolangma实现篇(九)</a></li></ul></div>]]></description><link>http://aimingoo.github.io/1-1747/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5c4</guid><category><![CDATA[博客]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 08 Oct 2017 14:29:50 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><h2 id="">【技术类】</h2>
<h3 id="qomo">Qomo技术系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-15/">从基础开始：Qomo OpenProject中的一些关键词</a></li>
<li><a href="http://aimingoo.github.io/1-16/">从基础开始：Qomo OpenProject中的一些关键词(2)</a></li>
<li><a href="http://aimingoo.github.io/1-18/">JavaScript面向对象的支持(1)</a></li>
<li><a href="http://aimingoo.github.io/1-21/">JavaScript面向对象的支持(2)</a></li>
<li><a href="http://aimingoo.github.io/1-22/">JavaScript面向对象的支持(3)</a></li>
<li><a href="http://aimingoo.github.io/1-23/">JavaScript面向对象的支持(4)</a></li>
<li><a href="http://aimingoo.github.io/1-24/">JavaScript面向对象的支持(5)</a></li>
<li><a href="http://aimingoo.github.io/1-26/">JavaScript面向对象的支持(6)</a></li>
<li><a href="http://aimingoo.github.io/1-27/">JavaScript面向对象的支持(7)</a></li>
<li><a href="http://aimingoo.github.io/1-30/">Qomolangma实现篇(一)：内核载入模块system.js的实现</a></li>
<li><a href="http://aimingoo.github.io/1-32/">Qomolangma实现篇(二)：命名空间和别名子系统的实现</a></li>
<li><a href="http://aimingoo.github.io/1-35/">Qomolangma实现篇(三)：兼容层设计</a></li>
<li><a href="http://aimingoo.github.io/1-36/">Qomolangma实现篇(四)：基本特性增强与多投事件系统</a></li>
<li><a href="http://aimingoo.github.io/1-38/">Qomolangma实现篇(五)：Qomo的OOP的语法和类继承体系</a></li>
<li><a href="http://aimingoo.github.io/1-39/">Qomolangma实现篇(六)：Qomo的OOP框架的实现技术</a></li>
<li><a href="http://aimingoo.github.io/1-42/">Qomolangma实现篇(七)：Qomo的接口机制</a></li>
<li><a href="http://aimingoo.github.io/1-43/">Qomolangma实现篇(八)：Qomo中的AOP框架</a></li>
<li><a href="http://aimingoo.github.io/1-47/">Qomolangma实现篇(九)：Qomo中的模板系统</a></li>
<li><a href="http://aimingoo.github.io/1-49/">Qomolangma框架库(一)：概述、工具、异常、调试与分析</a></li>
<li><a href="http://aimingoo.github.io/1-51/">Qomolangma框架库(二)：时间线与时间处理器</a></li>
<li><a href="http://aimingoo.github.io/1-57/">Qomolangma框架库(三)：处理池与处理机</a></li>
</ul>
<h3 id="">“前端要给力”系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-160/">前端要给力之：代码可以有多烂？</a></li>
<li><a href="http://aimingoo.github.io/1-162/">前端要给力之：URL应该有多长？</a></li>
<li><a href="http://aimingoo.github.io/1-163/">前端要给力之：原子，与原子联结的友类、友函数</a></li>
<li><a href="http://aimingoo.github.io/1-164/">前端要给力之：分解对象构造过程new()</a></li>
<li><a href="http://aimingoo.github.io/1-195/">前端要给力之：红绿灯大战中的火星生命-Promise</a></li>
</ul>
<h3 id="android">Android玩乐系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-178/">Android玩乐系列：修改汇编代码支持原生高清来电大头贴（一）</a></li>
<li><a href="http://aimingoo.github.io/1-179/">Android玩乐系列：修改汇编代码支持原生高清来电大头贴（二）</a></li>
<li><a href="http://aimingoo.github.io/1-180/">Android玩乐系列：修改汇编代码支持原生高清来电大头贴（三）</a></li>
</ul>
<h3 id="javascript">JavaScript类型讨论系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-167/">再谈JavaScript的数据类型问题</a></li>
<li><a href="http://aimingoo.github.io/1-168/">三谈类型问题：ECMAScript为什么错了？</a></li>
<li><a href="http://aimingoo.github.io/1-170/">JavaScript类型总览(图)</a></li>
</ul>
<h3 id="">元语言及其应用系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-112/">元语言基础技术之：在JS中如何自由地创建函数</a></li>
<li><a href="http://aimingoo.github.io/1-110/">QoBean的元语言系统（一）</a></li>
<li><a href="http://aimingoo.github.io/1-111/">QoBean的元语言系统（二）</a></li>
<li><a href="http://aimingoo.github.io/1-146/">为脚本语言平反-JavaScript篇（1）</a></li>
<li><a href="http://aimingoo.github.io/1-147/">为脚本语言平反-JavaScript篇（2）</a></li>
<li><a href="http://aimingoo.github.io/1-148/">为脚本语言平反-JavaScript篇（3）</a></li>
</ul>
<h3 id="">设计师的实战过程系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-113/">内训资料公开：设计师的实战过程(1)</a></li>
<li><a href="http://aimingoo.github.io/1-115/">内训资料公开：设计师的实战过程(2)</a></li>
<li><a href="http://aimingoo.github.io/1-116/">内训资料公开：设计师的实战过程(3)</a></li>
</ul>
<h2 id="">【论谈类】</h2>
<h3 id="">我读《人月神话》系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-63/">杀不死的人狼——我读《人月神话》（一）</a></li>
<li><a href="http://aimingoo.github.io/1-64/">杀不死的人狼——我读《人月神话》（二）</a></li>
<li><a href="http://aimingoo.github.io/1-65/">杀不死的人狼——我读《人月神话》（三）</a></li>
<li><a href="http://aimingoo.github.io/1-66/">杀不死的人狼——我读《人月神话》（四）</a></li>
<li><a href="http://aimingoo.github.io/1-67/">杀不死的人狼——我读《人月神话》（五）</a></li>
</ul>
<h3 id="">《大道至简》的幕后故事系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-70/">《大道至简》的幕后故事(1)</a></li>
<li><a href="http://aimingoo.github.io/1-71/">《大道至简》的幕后故事(2)：“愚公移山记”人物篇</a></li>
<li><a href="http://aimingoo.github.io/1-72/">《大道至简》的幕后故事(3)：“愚公移山记”事物篇</a></li>
<li><a href="http://aimingoo.github.io/1-73/">《大道至简》的幕后故事(4)：“愚公移山记”军事地理篇</a></li>
<li><a href="http://aimingoo.github.io/1-74/">《大道至简》的幕后故事(5)：“愚公移山记”军事谋略篇</a></li>
<li><a href="http://aimingoo.github.io/1-75/">《大道至简》的幕后故事：终结篇、勘误和PDF下载</a></li>
</ul>
<h3 id="vclrad">“VCL已死，RAD已死”系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-123/">VCL已死，RAD已死(1)</a></li>
<li><a href="http://aimingoo.github.io/1-124/">VCL已死，RAD已死(2)</a></li>
<li><a href="http://aimingoo.github.io/1-125/">VCL已死，RAD已死(3)</a></li>
<li><a href="http://aimingoo.github.io/1-126/">VCL已死，RAD已死(插播)</a></li>
<li><a href="http://aimingoo.github.io/1-129/">VCL已死，RAD已死(4)</a></li>
<li><a href="http://aimingoo.github.io/1-130/">关于“VCL已死、RAD已死”答读者问</a></li>
<li><a href="http://aimingoo.github.io/1-131/">VCL已死，RAD已死(5)</a></li>
<li><a href="http://aimingoo.github.io/1-132/">VCL已死，RAD已死(6) - 结语与预测</a></li>
</ul>
<h3 id="">《大道至易：实践者的思想》第二版发布小述系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-1735/">电子书《我的架构思想》小述</a></li>
<li><a href="http://aimingoo.github.io/1-1734/">电子书《程序原本》小述</a></li>
<li><a href="http://aimingoo.github.io/1-1736/">小述系列最终篇：说说《大道至易：实践者的思想》</a></li>
</ul>
<h3 id="oschina">OSCHINA答读者问系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-186/">OSCHINA答读者问之一：“软件工程”的学法与用法</a></li>
<li><a href="http://aimingoo.github.io/1-187/">OSCHINA答读者问之二：什么是架构？以及什么是架构师？</a></li>
<li><a href="http://aimingoo.github.io/1-188/">OSCHINA答读者问之三：架构是否就是把问题域理清楚？软件工程各要素可有比重？</a></li>
<li><a href="http://aimingoo.github.io/1-189/">OSCHINA答读者问之四：如何做好团队建设以及提高个人领导力？</a></li>
<li><a href="http://aimingoo.github.io/1-190/">OSCHINA答读者问之五：小作坊如何实施所谓的软件工程？</a></li>
<li><a href="http://aimingoo.github.io/1-191/">OSCHINA答读者问之六：杂谈（完结篇）</a></li>
</ul>
<h3 id="">访谈/媒体系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-100/">2007.03 旧文重发：谈企业软件架构设计</a></li>
<li><a href="http://aimingoo.github.io/59e374d2bc4c6b0274b469a3">2007.12 CSDN专家看台：盛大架构师周爱民回顾职业历程，分享十项建议</a></li>
<li><a href="http://aimingoo.github.io/59e30f5e72c9e7b37c383213">2014.09 访谈：真正的架构师是没有title的</a></li>
<li><a href="http://aimingoo.github.io/59e3041e72c9e7b37c383212">2015.03 访谈：技术高手≠技术领袖</a></li>
<li><a href="http://aimingoo.github.io/59e3026172c9e7b37c38320d">2016.04 访谈：周爱民老师最新加入的是一家什么样的创业公司?</a></li>
</ul>
<h2 id="">【应用类】</h2>
<h3 id="pdf">PDF工具系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-62/">关于做PDF的FAQ（一）～（四）</a></li>
<li><a href="http://aimingoo.github.io/1-1726/">Kindle电子书中该用多大的图片</a></li>
<li><a href="http://aimingoo.github.io/1-1728/">在电子书中使用SVG</a></li>
</ul>
<h3 id="">博客迁移手记系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-1719/">手记1：迁移博客之全程工具</a></li>
<li><a href="http://aimingoo.github.io/1-1720/">手记2：从本地博客到Github Pages的最佳指南及工具</a></li>
<li><a href="http://aimingoo.github.io/1-1721/">手记3：实例教学之Ghost模板定制</a></li>
<li><a href="http://aimingoo.github.io/1-1722/">手记4：谈谈Gitment中泄露secret的前因后果与解决方法</a></li>
<li><a href="http://aimingoo.github.io/1-1723/">手记5：如何获得一个支持HTTPS的免费空间</a></li>
<li><a href="http://aimingoo.github.io/1-1725/">手记6：改造Gitment</a></li>
<li><a href="http://aimingoo.github.io/1-1724/">博客迁移手记之快速导航</a></li>
</ul>
<h3 id="monster">Monster使用系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-1741/">Monster - 用Ghost写博客的终极利器</a></li>
<li><a href="http://aimingoo.github.io/1-1743/">将Monster用作网站离线下载的方法</a></li>
<li><a href="http://aimingoo.github.io/1-1742/">详解Monster的初始化及配置</a></li>
<li><a href="http://aimingoo.github.io/1-1744/">Monster的三种工作模式</a></li>
</ul>
<h2 id="">【非技术类】</h2>
<h3 id="">坐而论道系列</h3>
<ul>
<li>
<p><a href="http://aimingoo.github.io/1-205/">坐而论道（之一）</a></p>
</li>
<li>
<p><a href="http://aimingoo.github.io/1-206/">坐而论道（之二）</a></p>
</li>
<li>
<p><a href="http://aimingoo.github.io/1-211/">坐而论道（之三）</a></p>
</li>
<li>
<p><a href="http://aimingoo.github.io/1-219/">坐而论道（之四）</a></p>
</li>
<li>
<p><a href="http://aimingoo.github.io/1-259/">坐而论道（之五）：关于佛学中的“我”</a></p>
</li>
<li>
<p><a href="http://aimingoo.github.io/59e2e9b272c9e7b37c3831f0/">深夜食味记之一：番茄鸡蛋汤</a></p>
</li>
<li>
<p><a href="http://aimingoo.github.io/59e2eda072c9e7b37c3831f9/">深夜食味记之二：鱼香肉丝</a></p>
</li>
<li>
<p><a href="http://aimingoo.github.io/59e2ee4272c9e7b37c3831fd/">深夜食味记之三：麻婆豆腐</a></p>
</li>
<li>
<p><a href="http://aimingoo.github.io/59e2eecd72c9e7b37c383201/">深夜食味记之四：酸菜魔芋</a></p>
</li>
<li>
<p><a href="http://aimingoo.github.io/59e2f91672c9e7b37c383205/">深夜食味记之五：回锅肉</a></p>
</li>
</ul>
<h2 id="">【其它/综合】</h2>
<h3 id="">旧文重发系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-99/">旧文重发：程序员的一天</a></li>
<li><a href="http://aimingoo.github.io/1-100/">旧文重发：谈企业软件架构设计</a></li>
<li><a href="http://aimingoo.github.io/1-101/">旧文重发：产品线工程：团队迭代及其问题</a></li>
<li><a href="http://aimingoo.github.io/1-102/">旧文重发：程序员的七种武器</a></li>
<li><a href="http://aimingoo.github.io/1-103/">旧文重发：剑走偏锋：非主流的程序员</a></li>
<li><a href="http://aimingoo.github.io/1-104/">旧文重发：苹果是怎么吃到的？</a></li>
<li><a href="http://aimingoo.github.io/1-105/">旧文重发：做人、做事，做架构师——架构师能力模型解析</a></li>
</ul>
</div>]]></content:encoded></item><item><title><![CDATA[解决静态Blog中timeago显示问题的方法]]></title><description><![CDATA[<div class="kg-card-markdown"><p>因为使用的是Ghost博客的静态化页面，因此一篇文章发布到github上的时候显示的“发表于x分钟之前”，那么过了N多天再去看，还是这个“x分钟之前”。极不爽。所以，最近修改了一个timeAgo模块，用来搞定在静态博客中实时地显示timeAgo信息。</p>
<p>在页面中使用的时候也很简单，基本的做法是：</p>
<pre><code class="language-html">// 在页面中添加timeAgo模块
&lt;script src=&quot;https://aimingoo.github.io/assets/js/timeAgo.js&quot;&gt;&lt;/script&gt;

// 在需要显示的位置使用下面的代码
&lt;script&gt;document.writeln(timeAgo(&quot;DATETIME_OF_YOUR_POST&quot;))&lt;/script&gt;
</code></pre>
<p>在具体到Ghost的模板中使用的时候，会略有不同。</p>
<p><strong>1. 修改default.</strong></p></div>]]></description><link>http://aimingoo.github.io/1-1746/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5c3</guid><category><![CDATA[Ghost]]></category><category><![CDATA[博客]]></category><category><![CDATA[Javascript]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Wed, 27 Sep 2017 10:10:47 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>因为使用的是Ghost博客的静态化页面，因此一篇文章发布到github上的时候显示的“发表于x分钟之前”，那么过了N多天再去看，还是这个“x分钟之前”。极不爽。所以，最近修改了一个timeAgo模块，用来搞定在静态博客中实时地显示timeAgo信息。</p>
<p>在页面中使用的时候也很简单，基本的做法是：</p>
<pre><code class="language-html">// 在页面中添加timeAgo模块
&lt;script src=&quot;https://aimingoo.github.io/assets/js/timeAgo.js&quot;&gt;&lt;/script&gt;

// 在需要显示的位置使用下面的代码
&lt;script&gt;document.writeln(timeAgo(&quot;DATETIME_OF_YOUR_POST&quot;))&lt;/script&gt;
</code></pre>
<p>在具体到Ghost的模板中使用的时候，会略有不同。</p>
<p><strong>1. 修改default.hbs</strong></p>
<p>将下面的代码插入页面合适的位置以加载timeAgo模块：</p>
<pre><code class="language-html">&lt;!-- 将timeAgo.js置入模板的assets目录 --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;{{asset &quot;js/timeAgo.js&quot;}}&quot;&gt;&lt;/script&gt;

&lt;!-- 或使用在线的版本 --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://aimingoo.github.io/assets/js/timeAgo.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>如果你的模板有自己的初始化代码（一般放在<code>assets/js/index.js</code>文件中），应该将这行代码插入在初始化代码之前。</p>
<p><strong>2. 修改post.hbs</strong></p>
<p>在<code>post.hbs</code>中找到显示一个Post的日期的位置。它可能使用如下代码（缺省使用Ghost内置的timeago方法显示）：</p>
<pre><code class="language-bash">{{date published_at timeago=&quot;true&quot;}}
</code></pre>
<p>根据你打算在<code>post.hbs</code>使用该值的不同方法，可以直接输出，也可以在页面加载之后重置这个值。</p>
<p>如果是直接在该页面中输出，则将上面的改为：</p>
<pre><code class="language-html">&lt;script&gt;document.writeln(timeAgo(&quot;{{date published_at format='YYYY-MM-DDTHH:mm:ss.sssZ'}}&quot;))&lt;/script&gt;
</code></pre>
<p>注意上面的代码中，我们是用format参数来取得更加精确的时间值（而不是直接使用timeago格式的值）。</p>
<p><strong>3. 如果采用延迟加载的方法</strong></p>
<p>如果这个值是采用延迟加载的方法来显示的，那么它可能放在<code>post.hbs</code>的一对标签中。类似：</p>
<pre><code class="language-html">&lt;time class=&quot;post-date&quot; datetime=&quot;{{date format='YYYY-MM-DDTHH:mm:ss.sssZ'}}&quot; timeago=&quot;true&quot;&gt;&lt;/time&gt;
</code></pre>
<p>注意这里的<code>timeago</code>只是一个html标签属性——这个属性是我添加的，用来标示这个<code>&lt;time&gt;</code>标签将采用<code>timeago</code>方式显示。</p>
<p>在延迟加载的情况下，通常是在全局的ready回调中做一些针对当前页面的规格化操作。它可能通过在<code>default.hbs</code>中加载一个<code>.js</code>文件来进入。以我们上面说到过的例子，假如在<code>assets/js/index.js</code>文件中，那么它可能的代码是：</p>
<pre><code class="language-javascript">$(document).ready(function() {
  ...
})
</code></pre>
<p>在这个代码块中，加入下面的代码即可：</p>
<pre><code class="language-javascript">// 列出所有'class=&quot;post-date&quot;的标签
$(&quot;.post-date&quot;).each(function() {
    // 检查上面添加的'timeago'属性值是否为'true'
    if ($(this).attr(&quot;timeago&quot;) == &quot;true&quot;) {
        // 从'datetime'属性中取时间值，用timeAgo()转换并回写到当前标签中
        $(this).text(timeAgo($(this).attr(&quot;datetime&quot;)));
    }
});
</code></pre>
</div>]]></content:encoded></item><item><title><![CDATA[怎么会有两个“原本”]]></title><description><![CDATA[<div class="kg-card-markdown"><p>今天很突然地发现裘宗燕老师还翻译了一本《编程原本》，英文名是&quot;Elements of Programming&quot;，是C++的STL库之父Alexander Stepanov，简单地说就是“一个大牛”。而看到这个书名的时候，就是一惊：撞衫撞脸撞书名，我那本《程序原本》的英文名原本也是打算用&quot;Elements of Programming&quot;的呀。</p>
<p><img src="http://aimingoo.github.io/content/images/2017/09/two_elements.png" alt="two_elements"></p>
<blockquote>
<p>这两本书的介绍在这里：</p>
<ul>
<li>《编程原本》<a href="https://book.douban.com/subject/7564093/">https://book.douban.com/subject/7564093/</a></li>
<li>《程序原本》<a href="http://blog.csdn.net/aimingoo/article/details/75506782">http://blog.csdn.net/aimingoo/article/details/75506782</a></li>
</ul>
</blockquote>
<p>Alex这本书是2009年出的，中文版则等到了2012年。所以我写《大道至易》的时候并不知道这本书，这很正常。到2012年《大道至易》</p></div>]]></description><link>http://aimingoo.github.io/1-1745/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5c2</guid><category><![CDATA[程序原本]]></category><category><![CDATA[书序书评]]></category><category><![CDATA[读书]]></category><category><![CDATA[杂谈]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 24 Sep 2017 10:53:20 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>今天很突然地发现裘宗燕老师还翻译了一本《编程原本》，英文名是&quot;Elements of Programming&quot;，是C++的STL库之父Alexander Stepanov，简单地说就是“一个大牛”。而看到这个书名的时候，就是一惊：撞衫撞脸撞书名，我那本《程序原本》的英文名原本也是打算用&quot;Elements of Programming&quot;的呀。</p>
<p><img src="http://aimingoo.github.io/content/images/2017/09/two_elements.png" alt="two_elements"></p>
<blockquote>
<p>这两本书的介绍在这里：</p>
<ul>
<li>《编程原本》<a href="https://book.douban.com/subject/7564093/">https://book.douban.com/subject/7564093/</a></li>
<li>《程序原本》<a href="http://blog.csdn.net/aimingoo/article/details/75506782">http://blog.csdn.net/aimingoo/article/details/75506782</a></li>
</ul>
</blockquote>
<p>Alex这本书是2009年出的，中文版则等到了2012年。所以我写《大道至易》的时候并不知道这本书，这很正常。到2012年《大道至易》发行的时候，我在“程序原本”这一篇上用的标题是“程序源流”，是再到后来把这一部分独立成书并打算出电子版的时候，才用回到更早拟的名字，也就是《程序原本》。</p>
<p>于是现在就有了两个“原本”：《编程原本》和《程序原本》。</p>
<p>我仔细读了读Alex的《编程原本》，感叹于裘宗燕老师精准的翻译——是的，没错，这本书确实应该叫“编程（Programming）原本”。Alex在讲的，根本就不是“程序是怎么一回事”，而是“怎么写出好程序”——编程源于数学，因而可以从一个数学系统的构建和演进来理解编程的精髓，并“（或许就是）希望基于这种思维方法和开发技术，为范围广泛的软件系统建立起坚实基础”。由于这样的观念，Alex的《编程原本》中的数学系统既不是严格学术上的数学，也不是一般含义上的计算机系统。</p>
<p>在书中，Alex用于定义/构建数学系统的篇幅很小，也就是第一章（“基础”，14页）。而在这14页中，用于讨论“数/数据”的篇幅更少，大概只有3~4个小节。在全书接下来的篇幅中，Alex就基于这样的数学系统开始设计和分析算法，并以之解决实际问题了。</p>
<p>这与我在《程序原本》中讲述的内容与方法完全不同，并且存在着根本观念上的不同。在《程序原本》的第一个小节中，我就通过一个断言“算是程序之表，数是程序之本”，将整本书定调在了对“数”的讨论之中。由数的结构化延伸到算的结构化，以及后面的应用和系统的结构化，其本质上是在讨论：如今在“程序”中出现的种种元素，无非是大家在“结构化”这一个求解方向上的所得。因此我才在《我的架构思想》中提出了我对这所有观察作出的结论：程序是可被组织的元素。并由此提出进一步的观点：结构化——只是“程序是什么”的一个解，而绝非唯一解。</p>
<p>所以，我其实是在讨论“程序（Program）的原本”，而Alex在讨论的是“编程（Programming）的原本”。正是因此，《程序原本》中看到的就是数据，或者结构化视角下的可组织元素；《编程原本》中看到的就是数学系统，以及由此构建的算法与实现。</p>
<p>在<code>算法 + 数据结构 = 程序</code>这个经典的描述中，我讨论的是“数据结构”的问题，并进一步的讨论了“对数据、算法和程序的结构化”的问题，而Alex讨论的是算法问题。源于这种分析问题的剖面不同，Alex的《编程原本》要求读者有较高的数学基础，而《程序原本》则几乎对此没有什么要求——所以你看我在致谢中就只感谢了“我的小学数学老师”。^^.</p>
<p>不过《程序原本》要求你有很好的抽象思维能力，你可以把整本书看成一个完整的抽象思维与论证的训练——如何拿着最基础、简单的“数”的概念与原则，构建出对整个的系统描述。这本书回顾了你所有见到过的“程序”的样子，以及这些“样子”背后的逻辑，但是却并不教你写一行有效的代码、一个有用的算法，或者一个看起来有明确运行逻辑的系统。</p>
<p>算是程序之表，数是程序之本。</p>
<blockquote>
<p>又：</p>
<p>我最终觉得我在这本书的英文译名上还是犯了“严重且不可饶恕的错误”，所以只好悻悻然地将所有已经用过英文名的地方（例如github上）都进行了修改。我的《程序原本》这本书，今后就只用*&quot;Elements of Program&quot;*这个英文的书名吧。</p>
<p>好象更确切的译法是*“Elements of Programs”<em>？比如“算法 + 数据结构 = 程序”原书名就是</em>&quot;Algorithms + Data Structures = Programs&quot;*。算了，就这样吧！我的英文还没有好到可以较真这个东西的地步😹</p>
</blockquote>
</div>]]></content:encoded></item><item><title><![CDATA[Monster的三种工作模式]]></title><description><![CDATA[<div class="kg-card-markdown"><p>Monster有三种工作模式generate、update和preview。可以通过Monster的第一个参数来指定，在第一个参数缺省时直接使用generate模式。例如：</p>
<pre><code class="language-bash"># 下面两个指令是相同的
&gt; monster --generate
&gt; monster generate --generate
</code></pre>
<p>但Monster也有自己的<code>--help</code>参数，所以与generate模式下的<code>--help</code>参数不一致，后者显示的<code>makesite.sh</code>的帮助：</p>
<pre><code class="language-bash"># 显示monster的帮助
&gt; monster --help
# 显示generate模式(即makesite.sh)的帮助
&gt; monster generate --help
</code></pre>
<p>工作模式<code>preview</code>是非常简单的，它只是调用python来开启一个web服务器，这样你就可以在本地预览生成的页面文件了。</p>
<pre><code class="language-bash"># 可以指定端口地址（缺省为8000）
&gt; monster preivew 8010
Serving HTTP on 0.</code></pre></div>]]></description><link>http://aimingoo.github.io/1-1744/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5c1</guid><category><![CDATA[Monster]]></category><category><![CDATA[OpenSource Project]]></category><category><![CDATA[Ghost]]></category><category><![CDATA[博客]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Thu, 21 Sep 2017 15:50:03 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>Monster有三种工作模式generate、update和preview。可以通过Monster的第一个参数来指定，在第一个参数缺省时直接使用generate模式。例如：</p>
<pre><code class="language-bash"># 下面两个指令是相同的
&gt; monster --generate
&gt; monster generate --generate
</code></pre>
<p>但Monster也有自己的<code>--help</code>参数，所以与generate模式下的<code>--help</code>参数不一致，后者显示的<code>makesite.sh</code>的帮助：</p>
<pre><code class="language-bash"># 显示monster的帮助
&gt; monster --help
# 显示generate模式(即makesite.sh)的帮助
&gt; monster generate --help
</code></pre>
<p>工作模式<code>preview</code>是非常简单的，它只是调用python来开启一个web服务器，这样你就可以在本地预览生成的页面文件了。</p>
<pre><code class="language-bash"># 可以指定端口地址（缺省为8000）
&gt; monster preivew 8010
Serving HTTP on 0.0.0.0 port 8010 ...
</code></pre>
<h2 id="generateupdate">generate与update模式的原理不同</h2>
<p>generate工作模式定义了一个对“网站迁移的标准过程”的理解，亦即是分成四步：</p>
<ul>
<li>generate: 调用wget生成静态页</li>
<li>reset-domain：重置页面中的domain地址（它有两个前置过程）
<ul>
<li>pick-sitemap：尝试下载sitemaps文件</li>
<li>patch-version：修补assets等目录中的文件名后缀中的版本号</li>
</ul>
</li>
<li>short-path: 生成简短的网页路径</li>
<li>deploy-now: 部署到Github仓库（它有一个前置过程）
<ul>
<li>check-static：检查reset-domain过程之后的static目录</li>
</ul>
</li>
</ul>
<p>这个迁移并不是特指针对于Git Pages（xxxx.github.io）的，因此generate模式可以在非Ghost博客上正常工作，并且也可以将生成的静态网页Delpoy到非Git Pages的网站上去。所谓“Ghost -&gt; Git Pages”只是上述过程的一个运用而已。</p>
<p>generate工作模式在网页抓取上并不“积极”，它只是使用wget对Site入口（<code>/index.html</code>）进行深度递归并下载所有页面以及图片等等其它附件与资源而已。相对于Buster，它最大的进步是定义和有效利用了上述的四个阶段。</p>
<p>工作模式update在原理上就与generate不同。update工作模式是直接依赖Ghost的数据库文件的，它必须位于Monster可访问的路径上。update工作模式并没有上述的四个阶段，它缺省就直接读取数据库中最新的条目，并根据其title直接使用wget下载该页面和可能的资源。</p>
<p>update工作模式只有<code>fetch</code>和<code>deploy</code>两种行为。其中<code>fetch</code>行为是默认总是进行——除了在使用<code>--deploy-only</code>参数的情况下，而<code>deploy</code>行为是由<code>--deploy-now</code>或<code>--deploy-only</code>来触发的。</p>
<p>update工作模式的<code>deploy</code>行为是直接调用generate模式来实现的，所以事实上二者在Deploy功能上完全一致——只是在调用时，update模式会把<code>--pick-sitemap</code>和<code>--short-path</code>置为false，因为这两个步骤已经在update工作模式中处理过了，不需要generate模式去处理。</p>
<p>在update工作模式之内，<code>--pick-sitemap</code>和<code>--short-path</code>缺省是打开的，并且总是“推荐”使用short path——这在update工作模式中是更佳的选择。</p>
<h2 id="generate">generate模式的缺省行为</h2>
<p>下面的代码将直接调用generate模式的缺省行为：</p>
<pre><code class="language-bash">&gt; monster generate
</code></pre>
<p>在缺省情况下，Monster相关的配置如下：</p>
<pre><code class="language-bash"># GENERATE过程
GENERATE=false

# RESET_DOMAIN过程
PICK_SITEMAP=true
PATCH_VERSION=true
RESET_DOMAIN=true

# SHORT_PATH过程
SHORT_PATH=false

# DEPLOY过程
CHECK_STATIC=true
DEPLOY_NOW=false
</code></pre>
<p>因此generate模式缺省会跳过GENERATE过程，然后：</p>
<ul>
<li>判断Static path（例如缺省的<code>./static</code>）是否有效</li>
</ul>
<p>如果<code>./static</code>不存在，那么直接退出并提示：</p>
<blockquote>
<p>Abort because have not './static' directory.</p>
</blockquote>
<p>否则接下来处理：</p>
<ul>
<li>首先根据<code>PICK_SITEMAP</code>和<code>PATCH_VERSION</code>的配置来处理<code>RESET_DOMAIN</code>的前置过程；然后，</li>
<li>将检查生成文件的<code>SITE</code>值与发布到的<code>DOMAIN</code>地址，如果不一样（例如想从本地site生成文件并发布到domain），重置Static目录中所有文件中的domain值（<code>RESET_DOMAIN</code>）。</li>
</ul>
<p>最后跳过SHORT_PATH过程，并：</p>
<ul>
<li>检查一次Static目录中的文件是否都重置过domain（<code>CHECK_STATIC</code>）。</li>
</ul>
<h2 id="update">update模式的缺省行为</h2>
<p>下面的代码将直接调用update模式的缺省行为：</p>
<pre><code class="language-bash">&gt; monster update
</code></pre>
<p>对于update模式来说，以下参数是缺省置为true值的：</p>
<pre><code class="language-bash">PICK_ROBOTS_TXT=true
PICK_SITEMAP=true
SHORT_PATH=true
RESET_DOMAIN=true
</code></pre>
<p>前面说过：update与generate的行为逻辑很不一样。update模式的<code>fetch</code>行为看起来总是更“贪婪”的：</p>
<ul>
<li>它将尝试获取全部更新文件（依赖.sqlitedb中的信息来分析），并且如果发现有新的post创建，就会尝试获取全部列表文件——例如作者文章列表，以及首页文章索引等（包括<code>PICK_ROBOTS_TXT</code>、<code>PICK_SITEMAP</code>等等）。</li>
<li>一旦上述过程完成，<code>fetch</code>行为将进一步地检查Static目录，由于<code>SHORT_PATH</code>为true，所以它会尝试将Url中的路径变短。</li>
<li>最后，update模式会进入<code>RESET_DOMAIN</code>过程，并传入参数<code>--generate=false --pick-sitemap=false --short-path=false</code>以避免makesite.sh模块重复操作。</li>
</ul>
<p>update模式缺省并不Deploy（除非你在命令行上指定了<code>--deploy-now</code>，它缺省是false值）。</p>
<p>你无法让update过程什么也不做，这一点也与generate不同。唯一可算作例外的，是如果上一次update之后在Ghost中什么变化也没有（没有添加、删除或更新post），那么在update时就不会获得什么更新数据，也不会创建<code>./static</code>目录：</p>
<pre><code class="language-bash">&gt; monster update
Pick updated or new files ...

Try refresh author's pages ...
&gt; Skiped.
Abort because have not './static' directory.
</code></pre>
<h2 id="">开始构建你的网站</h2>
<p>你可以从一开始就选择两种工作模式之一。generate模式每一次总是做全站生成，而update模式只在第一次调用时，读sqlite库中的全部post做一次全站生成——并且部署。</p>
<p>如果你使用过<code>monster update --deploy-now</code>一次，那么Monster会在当前目录下生成一个<code>.sqlitedb</code>文件，用于存储数据库状态的一个时间点——以便下次update增量。</p>
<p>如果已经在用<code>monster generate</code>来直接做全站生成和部署了，那么第一次使用update工作模式时，可以使用下面的命令：</p>
<pre><code class="language-bash">&gt; monster update --init
File .sqlitedb saved.
</code></pre>
<p>这并不真的部署和更新任何东西，只是将<code>.sqlitedb</code>对齐到当前数据库。——之后，无论是<code>--deploy-now</code>还是<code>--deploy-only</code>，update模式每次都会更新<code>.sqlitedb</code>。</p>
<h2 id="generate">generate模式下的参数</h2>
<p>除了需要显式地用<code>monster generate --help</code>显示帮助信息之外，其它情况下都可以省掉第一个参数<code>generate</code>。其它的参数包括：</p>
<pre><code>#
# 参数开关，--paramName=true/false，只用--paramName相当于指定true
#

## 四个主要过程
# - 生成全站
--generate
# - 重置静态页中的domain(缺省为true)
--reset-domain
# - 生成短的Url路径
--short-path
# - 调用Git部署
--deploy-now

## 'RESET_DOMAIN'的前置操作(缺省为true)
# - 下载sitemap文件
--pick-sitemap
# - 修正文件名中的版本信息
--patch-version

## 'DEPLOY_NOW'的前置操作(缺省为true)
# - 检查Static目录中的静态页是否已经重置过domain
--check-static

## 在generate过程中是否显示更详细的信息(缺省为false)
--generate-info

#
# 传入其它配置值（字符串）
#

## 部署到的domain
--domain=&quot;...&quot;

## 下载静态页的Site，支持https
--site=&quot;http://...&quot;

## 存放静态页的目录
--static-path=&quot;...&quot;

#
# 其它
#

## 显示帮助
--help

## 显示版本号
--version
</code></pre>
<h2 id="update">update模式下的参数</h2>
<p>可以用<code>monster update</code>来按缺省配置运行udpate模式。其它的参数包括：</p>
<pre><code class="language-bash">#
# 参数开关，--paramName=true/false，只用--paramName相当于指定true
#

## 与Fetch和Deply行为相关
#- 是否调用reset-domain过程(缺省为true)
--reset-domain
#- 是否使用短路径(缺省为true)
--short-path
#- 在Fetch行为中，尝试为remove post行为而更新所有索引页
--sync-removed
#- 直接部署
--deploy-now
#- 不fetch文件，只部署Static目录
--deploy-only


## 特定文件获取
#- 总是下载/tag-cloud
--pick-static-tagcloud
#- 总是下载/profile-xxx
--pick-static-profile
#- 总是下载/archive-post
--pick-archive-post
#- 总是下载/robot.txt
--pick-robot-txt
#- 总是下载sitemap文件
--pick-sitemap
#- 强制下载上述--pick-xxxx和索引页等文件
--force


#
# 传入其它配置值（字符串）
#

## 部署到的domain
--domain=&quot;...&quot;
#- 在使用'--sync-issue'功能时，在Issue body中写入的Url上使用的协议名，缺省为'https'
--protocol=&quot;...&quot;

## 下载静态页的Site，支持https
--site=&quot;http://...&quot;

## 存放静态页的目录
--static-path=&quot;...&quot;

## 本地Ghost的数据库文件路径
--db=&quot;...&quot;

## 本地Ghost登录帐号，可以用'monster --list user'查看
#- (帐号邮箱)
--email=&quot;...&quot;

## 一个标记字符串，极少使用
#-（仅在update功能中用于检查特定文件中是否包含该字符串，以确保整个内容有效）
--ad-token=&quot;...&quot;
</code></pre>
<p>此外，Monster还在update工作模式下提供了一些直接命令，它们与一个（类似上述的）更新和部署过程无关，例如<code>—help</code>。这些命令包括：</p>
<pre><code class="language-bash">#
# 直接指令
#

## 生成.sqlitedb文件，对齐当前数据库
# - 'checksums'参数是仅仅由Monster内部使用的
--init [checksums]

## 将所有post的slug修改成'authorId-postId'格式
# - 这意味着生成的Url会是短路径名
--sync-slug

## 在对应的Github仓库中，为所有的post生成Gitment格式的Issue
# - Gitment需要用户为每个Post点一次创建Issue按钮，本功能可自动完成
# - 生成的Issue有两个标签：'${slug}'和'gitment'
# - 会忽略掉已经生成过的Issue，不会重复生成
--sync-issue

## 列出unment或user
# - unment是指“未创建Gitment格式Issue”的post
# - user是指Ghost库中的用户名
--list &lt;unment|user&gt;]

## 显示帮助
--help

## 显示版本号
--version
</code></pre>
<p><strong>关于<code>--sync-removed</code>参数</strong></p>
<p>Monster是通过记录数据库中的时间点的方法，来实现增量更新的。由于Ghost并没有在数据库中记录删除post的行为，也并不导致时间点变化，所以Monster也并没有办法简单确认当前Ghost环境中删除过post。</p>
<p>因此一旦用户只删除了post——而又没有任何其它添加或更新操作的话，那么就需要用下面的命令来提交一次update：</p>
<pre><code class="language-bash">&gt; monster --sync-removed --deploy-now
</code></pre>
<p>这个命令将会重建所有的索引页、标签页等，以便体现删除post这样的操作。</p>
<p>但是有一个小的问题：如果有“上一篇”、“下一篇”这样的导航，那么被删除post的链接仍然会出现在其它post页面上。——不过，由于是增量更新，所以这个链接仍然是可用的。换言之，被删除的post只是不再出现在各种列表页中，并没有真正移除。</p>
<p>很遗憾，目前这是无法直接解决的。</p>
<blockquote>
<p>注1：你可以删除<code>.sqlitedb</code>文件再执行<code>monster update</code>，这样可以全站重新生成一次，就可以了。</p>
<p>注2：monster只是从Static目录中复制了文件覆盖你的git仓库，这意味着它并没有<code>git rm …</code>来删除仓库中的既有文件——例如你刚刚删除掉的那个post。也就是说，即使你重新全站生成并deploy，那个post已经上传的的静态网页也仍然需要你手工从git仓库中删除。</p>
</blockquote>
<p><strong>关于<code>--force</code>参数</strong></p>
<p>这是一个用在update工作模式下的比较特别的参数。</p>
<p>前面说过，update工作模式是根据sqlite数据库的状况来实现的。这样一来，某些页面（通常是指定为static的、由特定模板或生成算法动态生成的网页）就不能被更新。在Ghost系统中，这些页面包括author和tag的索引页，以及手工定制的一些类似profile的页面。</p>
<p>当Monster发现有一个post新建的时候，它将认为所有上述页面都可能导致变化，所以就会主动（贪婪）地更新这些页面。但如果没有post新建——而只是更新了既有post，那么由于感知不到上述变化，所以就需要用<code>--force</code>来强制生成这些页面。</p>
<p>Monster不可能穷举所有类似的页面，所以在后续的版本中可能会提供一个机制来让用户定制这个页面列表。就目前而言，如果你有更多页面要处理，你只能手工修改updatesite.sh模块。这个文件位置在：</p>
<pre><code class="language-bash">&gt; brew list monster | grep updatesite
/usr/local/Cellar/monster/xxxx/libexec/updatesite.sh
</code></pre>
</div>]]></content:encoded></item><item><title><![CDATA[详解Monster的初始化及配置]]></title><description><![CDATA[<div class="kg-card-markdown"><p>尽管Monster并不强制你创建与初始化工作目录，并且也不强制依赖Ghost来工作，但是“Ghost + 工作目录”仍然<br>
是Monster的最佳使用场景。</p>
<blockquote>
<p>关于在没有Ghost的情况下使用Monster的说明请看这里：<a href="http://aimingoo.github.io/1-1743">将Monster用作网站离线下载的方法</a>。</p>
</blockquote>
<h2 id="">预备工作</h2>
<ul>
<li>你需要先启动Ghost并了解它运行在的本地地址</li>
</ul>
<pre><code class="language-bash">&gt; npm start
Ghost is running in development... 
Listening on 127.0.0.1:2368 
...
</code></pre>
<p>Ghost可以运行在不同的模式下，上面的是<code>development</code>模式，这种情况下它的缺省端口是<code>:2368</code>。</p>
<p>另外，你需要找到Ghost运行的目录中的sqlite数据库文件。假设你的Ghost运行的目录是在<code>${GHOST}</code>，那么这些数据文件的位置是在：</p>
<pre><code class="language-bash">&gt; grep -Fe '.db' ${GHOST}/config.js
filename: path.join(__dirname, '/</code></pre></div>]]></description><link>http://aimingoo.github.io/1-1742/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5bf</guid><category><![CDATA[OpenSource Project]]></category><category><![CDATA[Monster]]></category><category><![CDATA[Ghost]]></category><category><![CDATA[博客]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Tue, 19 Sep 2017 19:43:06 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>尽管Monster并不强制你创建与初始化工作目录，并且也不强制依赖Ghost来工作，但是“Ghost + 工作目录”仍然<br>
是Monster的最佳使用场景。</p>
<blockquote>
<p>关于在没有Ghost的情况下使用Monster的说明请看这里：<a href="http://aimingoo.github.io/1-1743">将Monster用作网站离线下载的方法</a>。</p>
</blockquote>
<h2 id="">预备工作</h2>
<ul>
<li>你需要先启动Ghost并了解它运行在的本地地址</li>
</ul>
<pre><code class="language-bash">&gt; npm start
Ghost is running in development... 
Listening on 127.0.0.1:2368 
...
</code></pre>
<p>Ghost可以运行在不同的模式下，上面的是<code>development</code>模式，这种情况下它的缺省端口是<code>:2368</code>。</p>
<p>另外，你需要找到Ghost运行的目录中的sqlite数据库文件。假设你的Ghost运行的目录是在<code>${GHOST}</code>，那么这些数据文件的位置是在：</p>
<pre><code class="language-bash">&gt; grep -Fe '.db' ${GHOST}/config.js
filename: path.join(__dirname, '/content/data/ghost.db')
filename: path.join(__dirname, '/content/data/ghost-dev.db')
filename: path.join(__dirname, '/content/data/ghost-test.db')
</code></pre>
<p>根据你启动的Ghost的版本不同，选择上面的一个库文件即可（一般是<code>ghost-dev.db</code>）。</p>
<ul>
<li>(<strong>discard</strong>)你需要安装Buster并确信它可用</li>
</ul>
<blockquote>
<p>在Monster早期版本中是调用Buster来生成全站的，但从v1.0.5版本开始就移除了对Buster的依赖。</p>
</blockquote>
<ul>
<li>你需要确信mac环境是否能运行Monster</li>
</ul>
<p>Monster依赖mac环境上的一些工具。如果你使用brew，那么可以用下面的命令来安装它：</p>
<pre><code class="language-bash">&gt; brew install wget jq curl
...
</code></pre>
<p>其它还会使用到的工具包括<code>sqlite3</code>、<code>sum</code>和<code>git</code>：<code>sqlite3</code>应该已经在安装Ghost时安装过了，而<code>sum</code>是MacOSX原生自带的；多数情况下，建议你安装<code>git</code>，使用<code>brew install git</code>即可。</p>
<blockquote>
<p><strong>注：</strong></p>
<p>Monster主要是用于生成静态网页，只有当你使用它的部署(deploy)功能时，才会用到<code>git</code>。所以事实上git并不是必须安装。</p>
<p>Monster使用Git api访问github issues，所以在使用评论相关的功能时并不要求安装git客户端。</p>
</blockquote>
<ul>
<li>最后，你需要安装Monster</li>
</ul>
<p>有两种方法安装Monster：</p>
<pre><code class="language-bash"># 使用Brew安装
&gt; brew install aimingoo/repo/monster

# 使用Git仓库安装
&gt; git clone https://github.com/aimingoo/monster
&gt; ln -s &quot;$(pwd)/monster/libexec/monster.sh&quot; /usr/local/bin/monster
&gt; chmod +x /usr/local/bin/monster
</code></pre>
<h2 id="">初始化及配置</h2>
<pre><code class="language-bash"># 创建一个目录，并在该目录中运行如下命令
&gt; monster --init
Your Github name or domain : aimingoo
Your Github access token, or Enter to skip: 
Your Ghost local account(e-mail), or Enter to skip: 
Your Ghost local .db file, or Enter to skip: 
Your Ghost site, or Enter set default [localhost:2368]: 
File .monster saved.
File .gitignore updated.
</code></pre>
<p>第一项配置<code>Github name or domain</code>总是必须输入的。它可以是一个名为<code>xxxx.github.io</code>的域名，或只是<code>xxxx</code>这样的域名前缀（亦即是Github用户账号名），此外还可以是一个非github的域名，例如<code>your.site.com</code>。</p>
<h3 id="domain">如果domain是无效的</h3>
<p>你可以使用任何domain——哪怕它不是真实的值。Monster的基本逻辑是：</p>
<ul>
<li><strong>GENERATE</strong>：下载一个<code>SITE</code>上的网页，放在<code>STATIC_PATH</code>中；并尝试</li>
<li><strong>RESET_DOMAIN</strong>：将网页中有关<code>SITE</code>的信息替换成<code>DOMAIN</code>；以及</li>
<li><strong>DEPLOY_NOW</strong>：将<code>STATIC_PATH</code>中的文件复制到当前目录，并尝试将当前目录作为Git仓库来部署。</li>
</ul>
<p>所以只要不启用RESET_DOMAIN（传入<code>--reset-domain=false</code>参数或者修改<code>.monster</code>配置），那么无效的DOMAIN是不影响Monster的使用的。</p>
<h3 id="domain">如果domain是空值</h3>
<p>在调用<code>monster --init</code>并输入缺省配置时，是不能使domain值为空的。</p>
<p>你可以编辑<code>.monster</code>以使该参数值为空，但这样的配置仅对update工作模式是有意义的。这会缺省使用<code>&lt;GITHUB_USER&gt;.github.io</code>来作为DOMAIN值，如果在update工作模式中调用了<code>--deploy-now</code>、<code>--deploy-only</code>或<code>--reset-domain</code>，那么该值也会通过命令行参数传入<code>makesite.sh</code>，以确保后者可用。</p>
<p>你不应当使<code>.monster</code>文件中的<code>DOMAIN</code>和<code>GITHUB_USER</code>值同时为空值。——如果是这样，你就必须总是从命令行中传入参数了。</p>
<h3 id="domain">关于domain的协议</h3>
<p>由于Monster并不访问你的domain（它只是更新本地静态网页中的内容），所以在配置文件中并不需要指定domain使用的协议，例如<code>https</code>或<code>http</code>。但有一个极小极小的例外，如果：</p>
<ul>
<li>你使用了Git issues来作评论，并且</li>
<li>你的domain并没有host在<code>xxxx.github.io</code>上，并且</li>
<li>你还打算使用Monster的<code>update --sync-issue</code>来管理它，</li>
</ul>
<p>那么你需要修改<code>.monster</code>中的<code>PROTOCOL</code>参数，缺省时它的值是<code>https</code>。</p>
<h3 id="monster">如果没有<code>.monster</code>文件</h3>
<p>如果你没有调用<code>monster --init</code>来初始化一个<code>.monster</code>文件，或者你误删除了它，那么你事实上仍然是可以使用Monster的。</p>
<p>这种情况下，对于generate工作模式来说，你必须从命令行通过<code>--domain</code>传入DOMAIN参数；对于update工作模式来说，则必须传入<code>--db</code>。当然你还可能需要传入其它在运行中要用到的参数，例如<code>GITHUB_USER</code>。</p>
<h2 id="monster">配置文件.monster的详细说明</h2>
<pre><code>## Github domain
#  - （参见上文）
DOMAIN=&quot;...&quot;

## Ghost .db file path
# - update工作模式下的相关功能依赖该配置
DB=&quot;/User/...&quot;

## Ghost site address
# - 要静态化（下载）的网站，可以是本地Ghost或远端的任何网址
# - 可以是任何网站（不是Ghost的网站，甚至不是博客）
SITE=&quot;http://...&quot;

## Github account, and rate of api access
# - 你的Github账号，是指当前工作目录对应的xxxx.github.io
GITHUB_USER=&quot;Your name&quot;
# - 你需要在Github后台为Git client创建一个Access token
GITHUB_TOKEN=&quot;Access token&quot;
# - 每次Github API访问之后sleep的时间（单位为秒）；当值为1时，意味着每分钟不会超过60次访问
GITHUB_APIRATE=1
# - 当读取Gitment等博客评论时，每次用Github取数据时的页大小（缺省为每页100条记录）
GITHUB_PAGESIZE=100

## Other
# - 你在本地Ghost中的登录帐号
EMAIL=&quot;...&quot;
# - 特殊情况下需要用到的domain的协议值（参见上文）
PROTOCOL=&quot;https&quot;

## Advertisement token string for your site
# - 一个标记字符串，极少使用（仅在update功能中用于检查特定文件中是否包含该字符串，以确保整个内容有效）
AD_TOKEN=&quot;&quot;

## Default directory of static files
# - 生成静态文件的路径
# - （对于Monster的preview工作模式来说，必须使用该配置而不能用命令行传入参数）
STATIC_PATH=&quot;./static&quot;

## Default behavior
# - 在GENERATE阶段中显示更多信息
GENERATE_INFO=false
# - 在update工作模式下，强制更新列表类网页
SYNC_REMOVED=false
# - 在操作过程中是否移除static目录中的文件名的'?xxxxxx'版本后缀
PATCH_VERSION=true
# - 是否启用RESET_DOMAIN阶段
RESET_DOMAIN=true
# - 是否启用SHORT_PATH阶段
SHORT_PATH=false
# - 是否启用CHECK_STATIC阶段
CHECK_STATIC=true

## Pick more files
# - 是否拾取静态化的云标签文件/tag-cloud
PICK_STATIC_TAGCLOUD=false
# - 是否拾取静态化的profile文件/profile-xxx
PICK_STATIC_PROFILE=false
# - 是否拾取静态化的归档文件/archive-post
PICK_ARCHIVES_POST=false
# - 是否拾取/robots.txt
PICK_ROBOTS_TXT=true
# - 是否拾取sitemap文件/sitemap-*
PICK_SITEMAP=true
# - 在update工作模式下，强制尝试上述PICK_xxxx和索引页等文件
FORCE=false

## Other override
# - 在SHORT_PATH阶段中不处理的目录名
IGNORE_LIST=(&quot;archives-post&quot; &quot;author&quot; &quot;page&quot; &quot;rss&quot; &quot;tag&quot; &quot;assets&quot; &quot;content&quot; &quot;shared&quot;)
# - 在PATCH_VERSION阶段中需要处理的目录名
VERDIR_LIST=(&quot;assets&quot; &quot;shared&quot; &quot;public&quot;)
</code></pre>
</div>]]></content:encoded></item><item><title><![CDATA[将Monster用作网站离线下载的方法]]></title><description><![CDATA[<div class="kg-card-markdown"><p>没有Ghost也是可以运行Monster，有极少功能是为这种情况准备的，例如用来作网站的离线下载。</p>
<h3 id="">在非工作目录中（不推荐）</h3>
<ul>
<li>将网站全站下载到<code>./static</code>目录</li>
</ul>
<pre><code class="language-bash"># 由于site与domain相同，所以不会触发reset-domain操作
&gt; monster --generate --site=&quot;http://your.site.com&quot; --domain=&quot;your.site.com&quot;

# OR，置reset-domain为false
&gt; monster --generate --site=&quot;http://your.site.com&quot; --domain=. --reset-domain=false
</code></pre>
<ul>
<li>对<code>./static</code>目录中的静态页面作<code>reset-domain</code>操作（缺省该选项是打开的）</li>
</ul>
<pre><code class="language-bash">&gt; monster --domain=</code></pre></div>]]></description><link>http://aimingoo.github.io/1-1743/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5c0</guid><category><![CDATA[Monster]]></category><category><![CDATA[博客]]></category><category><![CDATA[Ghost]]></category><category><![CDATA[OpenSource Project]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Tue, 19 Sep 2017 19:42:58 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>没有Ghost也是可以运行Monster，有极少功能是为这种情况准备的，例如用来作网站的离线下载。</p>
<h3 id="">在非工作目录中（不推荐）</h3>
<ul>
<li>将网站全站下载到<code>./static</code>目录</li>
</ul>
<pre><code class="language-bash"># 由于site与domain相同，所以不会触发reset-domain操作
&gt; monster --generate --site=&quot;http://your.site.com&quot; --domain=&quot;your.site.com&quot;

# OR，置reset-domain为false
&gt; monster --generate --site=&quot;http://your.site.com&quot; --domain=. --reset-domain=false
</code></pre>
<ul>
<li>对<code>./static</code>目录中的静态页面作<code>reset-domain</code>操作（缺省该选项是打开的）</li>
</ul>
<pre><code class="language-bash">&gt; monster --domain=&quot;your.site.com&quot;
</code></pre>
<ul>
<li>预览<code>./static</code>目录中的静态页面</li>
</ul>
<pre><code class="language-bash">&gt; monster preview
</code></pre>
<h3 id="">初始化一个工作目录用来下载</h3>
<p>我们可以将一个目录初始化，用作专门的网络离线下载（备份/归档）。</p>
<p><strong>初始化一个工作目录</strong></p>
<pre><code class="language-bash"># 直接用--init初始化一个工作目录，除了domain之外其它的跳过
#	- 随便填写一个domain地址即可，例如填写一个“.”符号
&gt; monster --init
Your Github name or domain: .
...

# 置RESET_DOMAIN=false
&gt; sed -i '' 's/[# ]*\(RESET_DOMAIN\)=.*/\1=false/' .monster

# 添加一行配置
&gt; echo &quot;GENERATE=true&quot; &gt;&gt; .monster
</code></pre>
<p><strong>常用操作</strong></p>
<pre><code class="language-bash"># 下载一个站点(例如https://aimingoo.github.io)
&gt; monster --site=&quot;https://aimingoo.github.io&quot;

# 将站点下载到指定目录
&gt; monster --site=&quot;https://aimingoo.github.io&quot; --static-path=&quot;./archive&quot;

# 不尝试下载sitemap文件
&gt; monster --site=&quot;https://aimingoo.github.io&quot; --pick-sitemap=false
</code></pre>
</div>]]></content:encoded></item><item><title><![CDATA[Monster - 用Ghost写博客的终极利器]]></title><description><![CDATA[<div class="kg-card-markdown"><h2 id="bustermonster">是时候从Buster转到Monster了</h2>
<p>我最先开始用Ghost写博客时，用来生成静态页面（并发布到<a href="https://aimingoo.github.io">aimingoo.github.io</a>）的工具是Buster。首先它确实不太好用，其次用它生成（generate）出来的页面还需要做许多的后续处理才能使用。由于这个缘故，我写了Monster这个工具的第一代产品并放在了我的<a href="https://github.com/aimingoo/ghost-utils">ghost-utils</a>仓库中，名为<code>makesite.sh</code>。</p>
<p><code>makesite.sh</code>其实是类似Buster的。由于采用了相同的实现方案，所以也就有着Buster的最根本的问题：每次都要对全站做重新生成。为此，我另外又写了一个脚本，名为<code>updatesite.sh</code>，用来实现增量生成基于Ghost的静态网站。</p>
<p>再之后，将这两个脚本合在一起，就变成了：</p>
<blockquote>
<p><strong>Monster</strong>，一个同时支持全量和增量生成Ghost静态网站的工具。</p>
</blockquote>
<p>这是一个用Bash写开源项目，Github地址在这里: <a href="https://github.com/aimingoo/monster">https://github.com/aimingoo/monster</a></p>
<blockquote>
<p><strong>注：</strong><code>makesite.sh</code>在早期就是Buster一个壳，从v1.0.5版本开始直接使用wget而不再依赖Buster。</p></blockquote></div>]]></description><link>http://aimingoo.github.io/1-1741/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5be</guid><category><![CDATA[OpenSource Project]]></category><category><![CDATA[博客]]></category><category><![CDATA[Ghost]]></category><category><![CDATA[Monster]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Tue, 19 Sep 2017 07:27:23 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><h2 id="bustermonster">是时候从Buster转到Monster了</h2>
<p>我最先开始用Ghost写博客时，用来生成静态页面（并发布到<a href="https://aimingoo.github.io">aimingoo.github.io</a>）的工具是Buster。首先它确实不太好用，其次用它生成（generate）出来的页面还需要做许多的后续处理才能使用。由于这个缘故，我写了Monster这个工具的第一代产品并放在了我的<a href="https://github.com/aimingoo/ghost-utils">ghost-utils</a>仓库中，名为<code>makesite.sh</code>。</p>
<p><code>makesite.sh</code>其实是类似Buster的。由于采用了相同的实现方案，所以也就有着Buster的最根本的问题：每次都要对全站做重新生成。为此，我另外又写了一个脚本，名为<code>updatesite.sh</code>，用来实现增量生成基于Ghost的静态网站。</p>
<p>再之后，将这两个脚本合在一起，就变成了：</p>
<blockquote>
<p><strong>Monster</strong>，一个同时支持全量和增量生成Ghost静态网站的工具。</p>
</blockquote>
<p>这是一个用Bash写开源项目，Github地址在这里: <a href="https://github.com/aimingoo/monster">https://github.com/aimingoo/monster</a></p>
<blockquote>
<p><strong>注：</strong><code>makesite.sh</code>在早期就是Buster一个壳，从v1.0.5版本开始直接使用wget而不再依赖Buster。</p>
</blockquote>
<h2 id="monster">Monster的功能</h2>
<ul>
<li>全量和增量生成Ghost静态网站</li>
<li>可以在本地预览或向<code>github.io</code>部署生成的网站</li>
<li>支持生成并不Host在<code>github.io</code>上的网站</li>
<li>支持同时管理多个网站，独立配置</li>
<li>支持在url中使用缩短路径的风格（使用更精减的ghost slug）</li>
<li>支持Ghost的多作者（multi-author）功能</li>
<li>支持基于github issues的评论管理（面向gitment的工具功能）</li>
</ul>
<h2 id="monster">安装Monster</h2>
<pre><code class="language-bash">&gt; brew install aimingoo/repo/monster
</code></pre>
<h2 id="">快速上手</h2>
<pre><code class="language-bash"># 了解ghost运行的本地地址(例如下面的127.0.0.1:2368)
&gt; npm start
Ghost is running in development... 
Listening on 127.0.0.1:2368 
...

# 如果你已经在Github上创建了自己的pages，那么你应该先将它clone到本地
#  - (设网站domain为xxxx.github.io)
&gt; git clone 'https://github.com/xxxx/xxxx.github.io'

# 配置初始化(用上面的项目作为工作目录)
#	- 可以不使用xxxx.github.io，而使用自己的domain，例如your.site.com
#	- 路径&quot;Ghost local .db file&quot;可用如下命令查看(或先略过它)：
#		&gt; grep -Fe '.db' ${GHOST安装目录}/config.js
&gt; cd xxxx.github.io
&gt; monster --init
Your Github name or domain: xxxx
Your Github access token, or Enter to skip: 
Your Ghost local account(e-mail), or Enter to skip: 
Your Ghost local .db file, or Enter to skip: 
Your Ghost site, or Enter set default [localhost:2368]: 
...

# 全站生成
&gt; monster --generate

# 更新
&gt; monster update

# 预览(ctrl+c退出)
&gt; monster preview
Serving HTTP on 0.0.0.0 port 8000 ...

# 发布/部署(在生成全站之后)
&gt; monster --deploy-now
# 或发布更新（在使用'monster update'之后）
&gt; monster update --deploy-only

# 其它

# 直接生成全站并发布
&gt; monster --generate --deploy-now
# 或在更新后直接发布
&gt; monster update --deploy-now
</code></pre>
<h2 id="">工作目录</h2>
<p>在使用<code>monster --init</code>初始化之后，当前目录就被Monster视为工作目录。</p>
<p>Monster会根据当前目录下的<code>.monster</code>配置工作，因此只需要为多个site建立不同的目录，就可以管理multi-domain了。</p>
<p>Monster会操作和维护当前目录下的<code>./static</code>目录来生成静态文件，你可以通过上述的<code>.monster</code>配置来改变这个目录的位置。</p>
<p>最后，当前目录下的<code>monster.log</code>和<code>.sqlitedb</code>也是由Monster来管理的。你可以手工编写一个名为<code>patchme.sh</code>的文件来实现一些复杂的操作，如果它存在，那么Monster会调用并管理它。</p>
<p>Monster的多数操作信息会直接出现在控制台，只有<code>monster --generate</code>和<code>monster update</code>会操作monster.log文件，前者总是覆盖整个文件，而后者是追加日志。</p>
<p>Monster会维护<code>.gitignore</code>或<code>.git/info/exclude</code>文件来避免git将多余的文件push到仓库。所以，上述<code>./static</code>目录以及<code>.monster</code>、<code>.sqlitedb</code>、<code>patchme.sh</code>和<code>monster.log</code>等文件也已经加入了git的ingore list。</p>
<h2 id="">高级特性</h2>
<p>关于Monster的Git issues评论、short path、sync、multi author等特性，请参考：</p>
<p><strong>阅读列表</strong></p>
<ul>
<li><a href="http://aimingoo.github.io/1-1742">详解Monster的初始化及配置</a></li>
<li><a href="http://aimingoo.github.io/1-1743">将Monster用作网站离线下载的方法</a></li>
<li><a href="http://aimingoo.github.io/1-1744">Monster的三种工作模式</a></li>
</ul>
</div>]]></content:encoded></item></channel></rss>
